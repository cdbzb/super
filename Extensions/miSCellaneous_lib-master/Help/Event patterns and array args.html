<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0433ff}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #008300}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p14 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; color: #cd1c00}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000; min-height: 12.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {color: #0326cb}
span.s5 {color: #008300}
span.s6 {color: #0433ff}
span.s7 {color: #cd1c00}
span.s8 {color: #ff7c00}
span.s9 {color: #434ccb}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>Event patterns and array args <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>setting and passing arrays and envelopes via patterns</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">This tutorial covers some use cases of array args, especially passing arrays to synths with patterns.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Examples</b></p>
<p class="p5"><br></p>
<p class="p4"><b><span class="s3">1.) Alternative writing of arrayed args in SynthDefs</span></b></p>
<p class="p6"><br></p>
<p class="p7">(</p>
<p class="p7">s = <span class="s4">Server</span>.local;</p>
<p class="p7"><span class="s4">Server</span>.default = s;</p>
<p class="p7">s.boot;</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p9">// SynthDef with array of overtone weights,</p>
<p class="p9">// weights can additionally be influenced with a dampExp arg unequal to 0,<span class="Apple-converted-space"> </span></p>
<p class="p9">// see examples below.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// The standard way to define array args:<span class="Apple-converted-space"> </span></p>
<p class="p9">// when appearing within the list of args, a literal Array must be used,</p>
<p class="p9">// shortcut (1..8) generates an Array with Integers from 1 to 8</p>
<p class="p8"><br></p>
<p class="p10"><span class="s4">SynthDef</span><span class="s2">(</span><span class="s5">\array_1a</span><span class="s2">, { </span>|out = 0, freq = 440, otAmps = #[1,1,1,1,1,1,1,1], dampExp = 0,</p>
<p class="p10"><span class="Apple-tab-span">	</span>att = 0.01, rel = 0.6, amp = 0.1, gate = 1, freqLag = 0.02, otLag = 0.02|</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, env, freqs, amps;</p>
<p class="p7"><span class="Apple-tab-span">	</span>freqs = (freq * (1..8)).clip(20, 20000).lag(freqLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>amps = ((otAmps / ((1..8) ** dampExp)).normalizeSum * amp).lag(otLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s4">SinOsc</span>.ar(freqs, 0, amps);</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s4">EnvGen</span>.ar(<span class="s4">Env</span>.asr(att, 1, rel), gate, doneAction: 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, <span class="s4">Splay</span>.ar(sig) * env)</p>
<p class="p7">}).add</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p9">// Note that SynthDef \array_1a uses the array arg's size (8) at two further places (arrays (1..8)).</p>
<p class="p9">// As a literal Array, by its nature, requires the explicit writing of its items,</p>
<p class="p9">// this becomes arkward with larger arrays and/or rewriting the SynthDef with other sizes.</p>
<p class="p9">// For those reasons the use of NamedControl turns out to be very convenient with array args,</p>
<p class="p9">// it also gives an easy way of lagging.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// Alternative to SynthDef \array_1a using NamedControl:</p>
<p class="p9">// Although a NamedControl can be written at any position within the SynthDef,</p>
<p class="p9">// it's a useful convention to invent it directly after the args list</p>
<p class="p9">// by assigning it to a variable of the same name (so code with literal Array args can be reused easily).</p>
<p class="p9">// With NamedControl the array size can now also be written as a variable,</p>
<p class="p9">// which allows to define SynthDefs with different array sizes on the fly.</p>
<p class="p9">// Also note NamedControl's shortcuts aSymbol.kr / aSymbol.kr</p>
<p class="p9">// which make its use even more comfortable.</p>
<p class="p8"><br></p>
<p class="p9">// define size for SynthDef</p>
<p class="p7">n = 8;</p>
<p class="p8"><br></p>
<p class="p9">// define SynthDef</p>
<p class="p9">// shortcut 1!n (short for 1.dup(n)) generates an Array of size n filled with 1.</p>
<p class="p8"><br></p>
<p class="p10"><span class="s4">SynthDef</span><span class="s2">(</span><span class="s5">\array_1b</span><span class="s2">, { </span>|out = 0, freq = 440, dampExp = 0,</p>
<p class="p10"><span class="Apple-tab-span">	</span>att = 0.01, rel = 0.6, amp = 0.1, gate = 1, freqLag = 0.02, otLag = 0.02|</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s6">var</span><span class="s2"> otAmps = </span><span class="s4">NamedControl</span><span class="s2">.kr(</span><span class="s5">\otAmps</span><span class="s2">, 1!n); </span>// shortcut: otAmps = \otAmps.kr(1!n);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, env, freqs, amps;</p>
<p class="p7"><span class="Apple-tab-span">	</span>freqs = (freq * (1..n)).clip(20, 20000).lag(freqLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>amps = ((otAmps / ((1..n) ** dampExp)).normalizeSum * amp).lag(otLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s4">SinOsc</span>.ar(freqs, 0, amps);</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s4">EnvGen</span>.ar(<span class="s4">Env</span>.asr(att, 1, rel), gate, doneAction: 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, <span class="s4">Splay</span>.ar(sig) * env)</p>
<p class="p7">}).add</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// As array sizes of SynthDefs are fixed you might want to define for a number</p>
<p class="p9">// of Integers and name the SynthDefs appropriately.</p>
<p class="p9">// Here's such a "SynthDef factory":</p>
<p class="p9">// we get SynthDefs of names \array_1b_1, ..., \array_1b_16 with corresponding array sizes,</p>
<p class="p9">// see Ex. 3b for a use case.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p7">(1..16).do { <span class="s6">|n|</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> name = <span class="s5">\array_1b</span> ++ <span class="s5">\_</span> ++ n;</p>
<p class="p10"><span class="s4"><span class="Apple-tab-span">	</span>SynthDef</span><span class="s2">(name, { </span>|out = 0, freq = 440, dampExp = 0,</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>att = 0.01, rel = 0.6, amp = 0.1, gate = 1, freqLag = 0.02, otLag = 0.02|</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">var</span><span class="s2"> otAmps = </span><span class="s4">NamedControl</span><span class="s2">.kr(</span><span class="s5">\otAmps</span><span class="s2">, 1!n); </span>// shortcut: otAmps = \otAmps.kr(1!n);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, env, freqs, amps;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>freqs = (freq * (1..n)).clip(20, 20000).lag(freqLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>amps = ((otAmps / ((1..n) ** dampExp)).normalizeSum * amp).lag(otLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>sig = <span class="s4">SinOsc</span>.ar(freqs, 0, amps);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>env = <span class="s4">EnvGen</span>.ar(<span class="s4">Env</span>.asr(att, 1, rel), gate, doneAction: 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, <span class="s4">Splay</span>.ar(sig) * env)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}).add</p>
<p class="p7">}</p>
<p class="p7">)<span class="Apple-tab-span">	</span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b><span class="s3">2.) Setting array args and array fields of a running synth</span></b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2a: Setting array args of a running synth</b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// start Synth, SynthDefs \array_1a, \array_1b and \array_1b_8 are equivalent</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 300, amp: 0.2])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// only odd partials (clarinet-like)</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\otAmps</span>, [1, 0, 1, 0, 1, 0, 1, 0])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// emphasize one partial</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\otAmps</span>, [1, 0, 1, 0, 1, 5, 1, 0])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// only lower ones</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\otAmps</span>, [1, 1, 1, 1, 0, 0, 0, 0])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// default again</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\otAmps</span>, [1, 1, 1, 1, 1, 1, 1, 1])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// force lower partials with dampExp &gt; 0</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\dampExp</span>, 1.5)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// force higher partials with dampExp &lt; 0</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\dampExp</span>, -1.5)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// default again</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\dampExp</span>, 0)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// release</p>
<p class="p8"><br></p>
<p class="p7">x.release</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2b: Setting array args of a running synth with Pbind of event type \set</b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// For many use cases Pmono (see 2c) is the most practical solution</p>
<p class="p9">// as it doesn't require explicit starting of a synth.</p>
<p class="p9">// However sometimes it is necessary to access the running synth itself,</p>
<p class="p9">// then a Pbind with event type \set is a good choice.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// start Synth silently</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 200, amp: 0])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// Pbind of event type set:</p>
<p class="p9">// args to be set must be listed.</p>
<p class="p9">// Note that the array arg requires double brackets (syntactic distinction from setting multiple nodes)</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\type<span class="s2">, </span>\set<span class="s2">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\id</span>, x,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\args</span>, #[freq, amp, dampExp, otAmps], <span class="s7">// must be given explicitely</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s5">\midinote</span><span class="s2">, </span><span class="s4">Pwhite</span><span class="s2">(45.0, 70), </span>// for midinote freq must be set</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dampExp</span>, <span class="s4">Pwhite</span>(0, 3),</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s5">\otAmps</span><span class="s2">, [[2, 1, 3, 2, 1, 2, 2, 1]] </span>// double brackets for array arg !</p>
<p class="p7">).play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// stop EventStreamPlayer and release Synth</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p7">x.release;</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// start Synth silently</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 200, amp: 0]);</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// Sequencing the array arg:</p>
<p class="p9">// rising spectral shape, falling fundamental</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// Array for Pseq, we need an array of doubly bracketed arrays or</p>
<p class="p9">// ref'd arrays as in Ex. 2c.</p>
<p class="p12"><br></p>
<p class="p7">o = [</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 0, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 1, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 1, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 1, 0, 1, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 1, 0, 1, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 0, 1, 0, 1, 0, 1]]</p>
<p class="p7">];</p>
<p class="p8"><br></p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\type<span class="s2">, </span>\set<span class="s2">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\id</span>, x,</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s5">\args</span><span class="s2">, #[freq, amp, otAmps], </span>// must be given explicitely</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\midinote</span>, <span class="s4">Pn</span>(<span class="s4">Plazy</span> { <span class="s4">Pseq</span>((70..50)) / rrand(1, 1.2) }),<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmps</span>, <span class="s4">Pseq</span>(o, 30)<span class="Apple-converted-space"> </span></p>
<p class="p7">).play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// stop EventStreamPlayer and release Synth</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p7">x.release;</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2c: Setting array args of a running synth with Pmono</b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// Rewriting second example of 2b, shorter with Pmono.</p>
<p class="p9">// Instead of doubly bracketed arrays you can choose Refs of Arrays also.</p>
<p class="p9">// Note that this alternative is not valid for a single nested Array as<span class="Apple-converted-space"> </span></p>
<p class="p9">// in the first example of 2b.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p7">o = [</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 1, 0, 0, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 0, 1, 0, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 1, 0, 1, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 0, 1, 0, 1, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 1, 0, 1, 0, 1, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 0, 1, 0, 1, 0, 1, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>`[1, 0, 0, 1, 0, 1, 0, 1]</p>
<p class="p7">];</p>
<p class="p8"><br></p>
<p class="p11"><span class="s2">p = </span><span class="s4">Pmono</span><span class="s2">(</span>\array_1a,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\midinote</span>, <span class="s4">Pn</span>(<span class="s4">Plazy</span> { <span class="s4">Pseq</span>((70..50)) / rrand(1, 1.2) }),<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmps</span>, <span class="s4">Pseq</span>(o, 30)<span class="Apple-converted-space"> </span></p>
<p class="p7">).play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// stop EventStreamPlayer from Pmono (synth is released also)</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2d: Setting i-th fields of a running synth</b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// start Synth</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 200, amp: 0.3])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// by default otAmps equals [1, 1, 1, 1, 1, 1, 1, 1]</p>
<p class="p8"><br></p>
<p class="p9">// Since SC 3.6.x there exists method seti for setting single elements of arrays:</p>
<p class="p9">// turn off high overtones</p>
<p class="p8"><br></p>
<p class="p7">x.seti(<span class="s5">\otAmps</span>, 7, 0)</p>
<p class="p8"><br></p>
<p class="p7">x.seti(<span class="s5">\otAmps</span>, 6, 0)</p>
<p class="p8"><br></p>
<p class="p7">x.seti(<span class="s5">\otAmps</span>, 5, 0)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">x.release;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// With older SC versions you can use the following helper functions to achieve the same.</p>
<p class="p9">// This requires that the SynthDef has been added in order to have control arg info in SynthDescLib.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p10"><span class="s8">~getCtlIndex</span><span class="s2"> = { </span>|defName, argName, index|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p7">    <span class="s6">var</span> x = <span class="s4">SynthDescLib</span>.global.at(defName.asSymbol).controls<span class="Apple-converted-space"> </span></p>
<p class="p7">        .collect({<span class="s6">|x|</span> x.name.asSymbol }).indexOf(argName.asSymbol);<span class="Apple-converted-space"> </span></p>
<p class="p7">    x !? { x + index };<span class="Apple-converted-space"> </span></p>
<p class="p7">};<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p10"><span class="s8">~setiID</span><span class="s2"> = { </span>|server, defname, nodeID, key, index, value|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p7">    server.sendMsg(15, nodeID, <span class="s8">~getCtlIndex</span>.(defname, key, index), value);<span class="Apple-converted-space"> </span></p>
<p class="p7">};<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p10"><span class="s8">~seti</span><span class="s2"> = { </span>|node, key, index, value|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p7">    <span class="s8">~setiID</span>.(node.server, node.defName, node.nodeID, key, index, value);<span class="Apple-converted-space"> </span></p>
<p class="p7">};<span class="Apple-converted-space"> </span></p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// start Synth</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 200, amp: 0.5])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// turn off high overtones</p>
<p class="p8"><br></p>
<p class="p7"><span class="s8">~seti</span>.(x, <span class="s5">\otAmps</span>, 7, 0)</p>
<p class="p8"><br></p>
<p class="p7"><span class="s8">~seti</span>.(x, <span class="s5">\otAmps</span>, 6, 0)</p>
<p class="p8"><br></p>
<p class="p7"><span class="s8">~seti</span>.(x, <span class="s5">\otAmps</span>, 5, 0)</p>
<p class="p8"><br></p>
<p class="p7">x.release;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2e: Setting i-th fields of a running synth with patterns</b></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// For SC versions before invention of method seti use helper functions from Ex. 2d in Pbind.</p>
<p class="p8"><br></p>
<p class="p9">// start Synth</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1a</span>, [freq: 200, amp: 0.3])</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// sequence setting of single fields</p>
<p class="p9">// As this is currently not integrated with Pmono or event type \set</p>
<p class="p9">// it must be done explicitely. Method 'makeBundle' with server latency arg</p>
<p class="p9">// ensures that array field setting is done in parallel to</p>
<p class="p9">// other settings triggered by the event.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// continously subtract and add 7 overtones</p>
<p class="p8"><br></p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\type<span class="s2">, </span>\rest<span class="s2">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmp</span>, <span class="s4">Pstutter</span>(7, <span class="s4">Pseq</span>([0,1], <span class="s9">inf</span>)),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\i</span>, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>((1..7))),</p>
<p class="p9">//<span class="Apple-tab-span">	</span>use Function ~seti (2d) for SC versions without method seti:</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\do</span>, <span class="s4">Pfunc</span> { <span class="s6">|e|</span> s.makeBundle(s.latency, { <span class="s8">~seti</span>.(x, <span class="s5">\otAmps</span>, e.i, e.otAmp) }) }</p>
<p class="p9">//<span class="Apple-tab-span">	</span>for newer SC versions with method seti you can use this line instead:</p>
<p class="p9">//<span class="Apple-tab-span">	</span>\do, Pfunc { |e| s.makeBundle(s.latency, { x.seti(\otAmps, e.i, e.otAmp) }) }<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-converted-space">   </span>).trace.play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p9">// stop player and synth</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p7">p.stop;</p>
<p class="p7">x.release;</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// This approach can be extended by setting more than one field per event.</p>
<p class="p9">// In some cases this might be a reasonable alternative to setting whole arrays</p>
<p class="p9">// of running synths (2b, 2c), which requires more OSC traffic.</p>
<p class="p8"><br></p>
<p class="p9">// start Synth from Ex. 1 with 16 overtones</p>
<p class="p8"><br></p>
<p class="p7">x = <span class="s4">Synth</span>(<span class="s5">\array_1b_16</span>, [freq: 100, amp: 0.3])</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// lists for bookkeeping of substracted and added overtones</p>
<p class="p7">a = (1..16).asList;</p>
<p class="p7">b = <span class="s4">List</span>[];</p>
<p class="p8"><br></p>
<p class="p9">// Function to shovel indices from list to list</p>
<p class="p8"><br></p>
<p class="p10"><span class="s2">f = { </span>|list1, list2|</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> x = list1.choose;</p>
<p class="p7"><span class="Apple-tab-span">	</span>list1.remove(x);</p>
<p class="p7"><span class="Apple-tab-span">	</span>list2.add(x);</p>
<p class="p7"><span class="Apple-tab-span">	</span>x</p>
<p class="p7">};</p>
<p class="p8"><br></p>
<p class="p9">// continously subtract and add 5 x 3 overtones</p>
<p class="p8"><br></p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\type<span class="s2">, </span>\rest<span class="s2">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmp</span>, <span class="s4">Pstutter</span>(5, <span class="s4">Pseq</span>([0,1], <span class="s9">inf</span>)),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// shoveling indices from a to b and back, outputting sorted index tripels</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\i</span>, <span class="s4">Pseq</span>([</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">Pfinval</span>(5, <span class="s4">Pclump</span>(3, <span class="s4">Pfunc</span> { f.(a, b) } )),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">Pfinval</span>(5, <span class="s4">Pclump</span>(3, <span class="s4">Pfunc</span> { f.(b, a) } ))</p>
<p class="p7"><span class="Apple-tab-span">	</span>], <span class="s9">inf</span>).collect(_.sort),</p>
<p class="p9">//<span class="Apple-tab-span">	</span>use Function ~seti (2d) for SC versions without method seti:</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\do</span>, <span class="s4">Pfunc</span> { <span class="s6">|e|</span> s.makeBundle(s.latency, { e.i.do { <span class="s6">|j|</span> <span class="s8">~seti</span>.(x, <span class="s5">\otAmps</span>, j, e.otAmp) } }) }<span class="Apple-converted-space">   </span></p>
<p class="p9">//<span class="Apple-tab-span">	</span>for newer SC versions with method seti you can use this line instead:</p>
<p class="p9">//<span class="Apple-tab-span">	</span>\do, Pfunc { |e| s.makeBundle(s.latency, { e.i.do { |j| x.seti(\otAmps, j, e.otAmp) } }) }<span class="Apple-converted-space"> </span></p>
<p class="p7">).trace.play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p9">// stop player and synth</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p7">p.stop;</p>
<p class="p7">x.release;</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 2f: Alternatives with demand ugens</b></p>
<p class="p5"><br></p>
<p class="p9">// Besides from passing arrays, array sequencing can be<span class="Apple-converted-space"> </span></p>
<p class="p9">// done within synths by demand ugens.</p>
<p class="p9">// This is saving OSC bandwidth, especially with large arrays and short durations,</p>
<p class="p9">// for more complicated sequencing tasks coding might be harder than with patterns.</p>
<p class="p12"><br></p>
<p class="p7">(</p>
<p class="p9">// array sequencing within SynthDef</p>
<p class="p8"><br></p>
<p class="p7">q = [</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 1, 0, 0, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 0, 1, 0, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 1, 0, 1, 0, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 0, 1, 0, 1, 0, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 1, 0, 1, 0, 1, 0, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 0, 1, 0, 1, 0, 1, 0],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[1, 0, 0, 1, 0, 1, 0, 1]</p>
<p class="p7">];</p>
<p class="p8"><br></p>
<p class="p9">// duration will have to be passed with a key unequal to reserved keyword \dur</p>
<p class="p8"><br></p>
<p class="p10"><span class="s4">SynthDef</span><span class="s2">(</span><span class="s5">\array_1c</span><span class="s2">, { </span>|out = 0, freq = 440, dampExp = 0, duration = 0.2,</p>
<p class="p10"><span class="Apple-tab-span">	</span>att = 0.01, rel = 0.6, amp = 0.1, gate = 1, freqLag = 0.02, otLag = 0.02|</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> otAmps, sig, env, freqs, amps, arr;</p>
<p class="p7"><span class="Apple-tab-span">	</span>otAmps = <span class="s4">Demand</span>.kr(<span class="s4">Impulse</span>.kr(1 / duration), 0, <span class="s4">Dseq</span>(q, <span class="s9">inf</span>));</p>
<p class="p7"><span class="Apple-tab-span">	</span>freqs = (freq * (1..8)).clip(20, 20000).lag(freqLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>amps = ((otAmps / ((1..8) ** dampExp)).normalizeSum * amp).lag(otLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s4">SinOsc</span>.ar(freqs, 0, amps);</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s4">EnvGen</span>.ar(<span class="s4">Env</span>.asr(att, 1, rel), gate, doneAction: 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, <span class="s4">Splay</span>.ar(sig) * env)</p>
<p class="p7">}).add;</p>
<p class="p8"><br></p>
<p class="p9">// SynthDef for complete server-side sequencing<span class="Apple-converted-space"> </span></p>
<p class="p9">// takes midiseq as array arg</p>
<p class="p8"><br></p>
<p class="p10"><span class="s4">SynthDef</span><span class="s2">(</span><span class="s5">\array_1d</span><span class="s2">, { </span>|out = 0, dampExp = 0, duration = 0.2, divLo = 1, divHi = 1.2,</p>
<p class="p10"><span class="Apple-tab-span">	</span>att = 0.01, rel = 0.6, amp = 0.3, gate = 1, freqLag = 0.02, otLag = 0.02|</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> midiseq = <span class="s5">\midiseq</span>.kr((70..50));</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> trig, otAmps, sig, env, freq, freqs, amps, arr;</p>
<p class="p7"><span class="Apple-tab-span">	</span>trig = <span class="s4">Impulse</span>.kr(1 / duration);</p>
<p class="p7"><span class="Apple-tab-span">	</span>otAmps = <span class="s4">Demand</span>.kr(trig, 0, <span class="s4">Dseq</span>(q, <span class="s9">inf</span>));</p>
<p class="p7"><span class="Apple-tab-span">	</span>freq = <span class="s4">Demand</span>.kr(trig, 0, <span class="s4">Dseq</span>(midiseq, <span class="s9">inf</span>) /<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">Dstutter</span>(midiseq.size, <span class="s4">Dwhite</span>(divLo, divHi))).midicps;</p>
<p class="p7"><span class="Apple-tab-span">	</span>freqs = (freq * (1..8)).clip(20, 20000).lag(freqLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>amps = ((otAmps / ((1..8) ** dampExp)).normalizeSum * amp).lag(otLag);</p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s4">SinOsc</span>.ar(freqs, 0, amps);</p>
<p class="p7"><span class="Apple-tab-span">	</span>env = <span class="s4">EnvGen</span>.ar(<span class="s4">Env</span>.asr(att, 1, rel), gate, doneAction: 2);</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, <span class="s4">Splay</span>.ar(sig) * env)</p>
<p class="p7">}).add</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// equivalent to Ex 2c</p>
<p class="p9">// still using a pattern for non-array sequencing</p>
<p class="p8"><br></p>
<p class="p11"><span class="s2">p = </span><span class="s4">Pmono</span><span class="s2">(</span>\array_1c<span class="s2">,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\duration<span class="s2">, </span><span class="s4">Pkey</span><span class="s2">(</span>\dur<span class="s2">),</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\midinote</span>, <span class="s4">Pn</span>(<span class="s4">Plazy</span> { <span class="s4">Pseq</span>((70..50)) / rrand(1, 1.2) }),<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3</p>
<p class="p7">).play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// equivalent, now all done by synth</p>
<p class="p8"><br></p>
<p class="p11"><span class="s2">x = </span><span class="s4">Synth</span><span class="s2">(</span>\array_1d<span class="s2">)</span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p9">// set midi sequence<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\midiseq</span>, (50..70))</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\midiseq</span>, (70..50))</p>
<p class="p8"><br></p>
<p class="p7">x.set(<span class="s5">\midiseq</span>, (70..50).scramble)</p>
<p class="p8"><br></p>
<p class="p7">x.release</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b><span class="s3">3.) Sequencing synths with array args by Pbind</span></b></p>
<p class="p8"><br></p>
<p class="p5"><br></p>
<p class="p4"><b>Ex. 3a: Sequencing synths of same definition with array args by Pbind</b></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p9">// Using a Pbind with array args is straightforward,</p>
<p class="p9">// it's just important to remember that arrays must be in<span class="Apple-converted-space"> </span></p>
<p class="p9">// double brackets (or wrapped into Refs).<span class="Apple-converted-space"> </span></p>
<p class="p9">// Written explicitely it looks a bit odd as you end up with<span class="Apple-converted-space"> </span></p>
<p class="p9">// three brackets at begin and end:</p>
<p class="p9">// Pseq([[[1, 1, 0, 0, 0, 0, 0, 0]], ... , [[1, 0, 0, 1, 0, 1, 0, 1]]], 100)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// Array o from definitions in Ex. 2b / 2c.</p>
<p class="p12"><br></p>
<p class="p7">o = [</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 0, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 1, 0, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 1, 0, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 1, 0, 1, 0, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 1, 0, 1, 0]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 0, 1, 0, 1, 0, 1]]</p>
<p class="p7">];</p>
<p class="p12"><br></p>
<p class="p9">// generating multiple nodes per event is also no problem,</p>
<p class="p9">// arrays from o are sent to both nodes here:</p>
<p class="p8"><br></p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\instrument<span class="s2">, </span>\array_1a<span class="s2">,<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\stepsPerOctave<span class="s2">, 5,</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\octave<span class="s2">, 4,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\note</span>, <span class="s4">Pstutter</span>(7, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>((0..4)))) + [0, -4],<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmps</span>, <span class="s4">Pseq</span>(o, <span class="s9">100</span>)</p>
<p class="p7">).trace.play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 3b: Sequencing synths with different array arg sizes by Pbind</b></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p9">// By using the Array o in the last examples we did a kind of zeropadding:</p>
<p class="p9">// setting unused elements to zero.</p>
<p class="p9">// When altering one running synth (as with event type \set or Pmono)</p>
<p class="p9">// one can only save OSC messages if less than all fields are changed, see Ex. 2e.</p>
<p class="p8"><br></p>
<p class="p9">// When continuously generating new synths – as with 'normal' Pbind of type \note –</p>
<p class="p9">// there is another alternative: using SynthDefs of dedicated array arg sizes per event.</p>
<p class="p9">// This is the use case of a "SynthDef factory" as described in Ex. 1</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// needs SynthDefs from "factory" in Ex. 1</p>
<p class="p8"><br></p>
<p class="p7">q = [</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 1]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 1, 1, 1]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 0, 1, 0, 1, 0, 1, 0, 1]],</p>
<p class="p7"><span class="Apple-tab-span">	</span>[[1, 1, 0, 1, 0, 1, 0, 1, 0, 1]]</p>
<p class="p7">];</p>
<p class="p8"><br></p>
<p class="p7">p = <span class="s4">Pbind</span>(</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\otAmps</span>, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>(q), 100),</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\size</span>, <span class="s4">Pkey</span>(<span class="s5">\otAmps</span>).collect { <span class="s6">|x|</span> x[0].size.asSymbol },</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s5">\instrument</span><span class="s2">, </span><span class="s4">Pkey</span><span class="s2">(</span><span class="s5">\size</span><span class="s2">).collect { </span><span class="s6">|x|</span><span class="s2"> </span><span class="s5">\array_1b_</span><span class="s2"> ++ x }, </span>// SynthDef depends on chosen otAmp array</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, 0.2,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\amp</span>, 0.3,</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\stepsPerOctave<span class="s2">, 7,</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\octave<span class="s2">, 4,</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\note</span>, <span class="s4">Pstutter</span>(3, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>((0..4)))) + <span class="s4">Pn</span>(<span class="s4">Pshuf</span>([[0, 2], [0, 4, 8], [0, -3, -5, -8]]))<span class="Apple-converted-space"> </span></p>
<p class="p7">).trace.play</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b><span class="s3">Ex. 4: Sequencing synths with envelope array args by Pbind</span></b><b><span class="Apple-converted-space"> </span></b></p>
<p class="p5"><br></p>
<p class="p12"><br></p>
<p class="p9">// Env objects have a representation in a special Array format –</p>
<p class="p9">// which you can get with anEnv.asArray – the task of passing Env data to synths can thus be</p>
<p class="p9">// reduced to the task of passing Arrays in this special format.</p>
<p class="p9">// Nevertheless direct passing of Envs is possible also.</p>
<p class="p8"><br></p>
<p class="p7">(</p>
<p class="p9">// NamedControl is recommended in that case as a literal Array of special format would be impractical.</p>
<p class="p9">// Define a SynthDef with maximum envelope size you expect to pass</p>
<p class="p8"><br></p>
<p class="p10"><span class="s4">SynthDef</span><span class="s2">(</span><span class="s5">\envArray_1</span><span class="s2">, { </span>|out = 0, freq = 440, amp = 0.1, timeScale = 1, gate = 1|</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, env, envArray, envSig;</p>
<p class="p7"><span class="Apple-tab-span">	</span>envArray = <span class="s4">Env</span>([0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0]).asArray; <span class="s7">// works also without '.asArray'</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span>env = </span><span class="s5">\env</span><span class="s2">.kr(envArray);<span class="Apple-converted-space">  </span></span>// shortcut for NamedControl.kr(\env, envArray)</p>
<p class="p7"><span class="Apple-tab-span">	</span>envSig = <span class="s4">EnvGen</span>.kr(env, gate, timeScale: timeScale, doneAction: 2);<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span>sig = <span class="s4">Saw</span>.ar([freq, freq * 2.01], amp);<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s4">Out</span>.ar(out, sig * envSig)</p>
<p class="p7">}).add</p>
<p class="p7">)</p>
<p class="p13"><br></p>
<p class="p14">// Pbind uses event type \on to avoid setting gate to 0 and receiving messages "node not found",</p>
<p class="p14">// synths are ended by envelopes anyway.</p>
<p class="p13"><br></p>
<p class="p13"><br></p>
<p class="p15">(<span class="Apple-converted-space"> </span></p>
<p class="p15">p = <span class="s4">Pbind</span>(<span class="Apple-converted-space"> </span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\type<span class="s2">, </span><span class="s4">Pshuf</span><span class="s2">([</span>\on<span class="s2">, </span>\on<span class="s2">, </span>\rest<span class="s2">], </span><span class="s9">inf</span><span class="s2">),</span></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\instrument<span class="s2">, </span>\envArray_1<span class="s2">,<span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s5">\dur</span>, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>([1, 1/2, 1/2]), 30),<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s5">\midinote</span>, <span class="s4">Pn</span>(<span class="s4">Pshuf</span>((40..80))) + <span class="s4">Pn</span>(<span class="s4">Pshuf</span>([[0.5, 11.5], [0, 4], [0, -7], [-0.5, -9.5]])),</p>
<p class="p16"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// envData contains env types, determined by levels and times.</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// Times are only relations, within the synthdef they are scaled by the timeScale arg.</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span>\envData<span class="s2">, </span><span class="s4">Pn</span><span class="s2">(</span><span class="s4">Pshuf</span><span class="s2">([<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[[0, 1, 0], [1, 1]],<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[[0, 1, 1/4, 1, 0], [1, 1, 1, 1]],<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[[0, 1, 1/4, 1, 1/4, 1, 0], [1, 1, 1, 1, 1, 1]]</p>
<p class="p7"><span class="Apple-tab-span">	</span>])),</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// *x splits the envData array into levels and times, Env is converted in to an Array automatically</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\env</span>, <span class="s4">Pkey</span>(<span class="s5">\envData</span>).collect { <span class="s6">|x|</span> <span class="s4">Env</span>(*x) },<span class="Apple-converted-space"> </span></p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// when wanting to pass the Array explicitely it would require</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// wrapping into an additional Array which is necessary for passing:</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span></span>// \env, Pkey(\envData).collect { |x| [Env(*x).asArray] },<span class="Apple-converted-space"> </span></p>
<p class="p12"><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s5">\timeScale</span>, <span class="s4">Pfunc</span> { <span class="s6">|e|</span> e.dur / e.envData[1].sum }<span class="Apple-converted-space"> </span></p>
<p class="p7">).trace.play;<span class="Apple-converted-space"> </span></p>
<p class="p7">)<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p7">p.stop;</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
</body>
</html>
