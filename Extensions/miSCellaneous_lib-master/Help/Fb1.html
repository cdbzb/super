<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica}
p.p8 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica}
p.p10 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0326cb}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0433ff}
p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p19 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {text-decoration: underline ; color: #0000ee}
span.s5 {font: 9.0px Monaco}
span.s6 {color: #0326cb}
span.s7 {color: #0433ff}
span.s8 {color: #434ccb}
span.s9 {font: 9.0px Monaco; color: #cd1c00}
span.s10 {color: #cd1c00}
span.s11 {color: #ff7c00}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>Fb1<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>single sample feedback / feedforward pseudo ugen</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="../miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p1"><b>Inherits from: UGen</b></p>
<p class="p4"><br></p>
<p class="p1">Fb1 provides an interface for single sample feedback and feedforward at audio rate, the defining relation with (formal) access to previous samples is passed as a Function, which might involve additional UGens. Fb1 works with arbitrary blockSizes and also allows to refer to samples earlier than one blockSize before. This includes linear filter definitions of arbitrary length with dynamic coefficients as well as all kinds of nonlinear calculations of feedback and feedforward data (FOS and SOS UGens cover the linear case with lengths 1 and 2, LTI the general linear case).<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1"><b>HISTORY AND CREDITS:</b> There have been long discussions on single-sample feedback in SC. The most simple, but CPU-intense strategy is setting the server's blockSize to 1. Julian Rohrhuber gave a number of examples with Dbufrd / Dbufwr. SC's folder 'Examples' contains the files single_sample_feedback.scd and single_sample_feedback_02.scd. Special solutions are also possible with Delay1, Delay2 and other UGens. This particular implementation is based on Nathaniel Virgo's suggestion of iteratively writing to and reading from Buffers of blockSize – big credit for this! See also Nathaniel Virgo's Feedback quark for his feedback classes Fb and FbNode. Thanks also to James Harkins for his remarks on graph order. See Ex.1a for the basic feedback implementation principle. I implemented the ar feedforward option by temporary buffers for ar writing and kr reading, the feedback / feedforward relation can now be passed via a Function with 'in' and 'out' args. That way the syntax looks very similar to the common notations used for filter descriptions and also applies directly to the multichannel case. Most other options of Fb1 are for special multichannel handling and differentiated lookback definitions, which can help to save a lot of UGens.</p>
<p class="p2"><br></p>
<p class="p1"><b>WARNING: </b>Be careful with amplitudes, feedback can become loud! It is highly recommended to take measures to avoid blowup, e.g. by limiting operators (tanh, softclip, distort) and/or using MasterFX from the JITLibExtensions quark. Also consider that short iteration cycles can produce loud high pitches, wrapping lopass filters is useful!<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1"><b>NOTE: </b>The convenience of direct definition of the feedback / feedforward relation comes with the price of a large number of UGens involved. You might want to allow a higher number of UGens with the server option numWireBufs. You might also want to experiment with blockSizes smaller than 64 and larger than 1 (e.g. 8, 16 or 32). Check the <b>graphOrderType </b>arg, other values might cause considerable CPU saving and/or shortening of synthdef compile time.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1"><b>See also: </b><a href="GFIS.html"><span class="s4">GFIS</span></a></p>
<p class="p2"><br></p>
<p class="p5"><b>Creation / Class Methods</b></p>
<p class="p6"><br></p>
<p class="p7"><span class="s5"><span class="Apple-tab-span">	</span></span>Creates a new Fb1 object.</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p7"><b><span class="Apple-tab-span">	</span>*new (func, in, outSize = 0, inDepth = 1, outDepth = 2, inInit, outInit, blockSize = 64, blockFactor = 1, leakDC = true, leakCoef = 0.995)</b></p>
<p class="p8"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>func </b>- The Function to define the feedback / feedforward relation. The Function should take<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the two arguments 'in' and 'out', both understood as nested multichannel signals,</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>additionally a block index is passed (Ex. 3e).<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Each 'in' / 'out' item of the arrays represents current or previous samples,</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for all points in time the samples are passed in specific array shapes,</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>which are determined by the shapes of <b>in </b>and <b>outSize.</b></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Allowed are pure signals (size = 0) and nested SequenceableCollections at maximum:</p>
<p class="p9"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>e.g.<b> outSize </b>can be 0, 3, or [0, 2, 5], accordingly <b>in </b>signals can be of sizes<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0, i or [i1, ... , in] with i, ij &gt;= 0.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Note that 'in' and 'out' only formally represent ar feedback and feedforward signals,</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>technically kr UGens (BufRd.kr) are passed, the ar signals are reconstructed at the end<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>by reading (arrays of) Buffers.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The Function should return the multichannel UGen to be referred to with 'out',</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the shapes of the returned UGens and <b>outSize </b>must be the same.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Furthermore the meaning of 'in' and 'out' depends on the <b>inDepth</b> and <b>outDepth </b>arguments.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an Integer is passed to them (default), the indices of 'in' resp. 'out'<span class="Apple-converted-space">  </span>correspond to the<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lookback indices:</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>E.g. out[1] refers to the last output sample(s) (of shape <b>outSize</b>), out[2] to the output sample(s) before<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the last output sample(s) etc. This is compliant with the convention of writing out[i-1], out[i-2] etc.,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[0] refers to out[i-blockSize].<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>For a multichannel 'in' / 'out' signal, depth can be differentiated, which saves UGens<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in the case of "gaps" in the recursion:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>E.g. for a three-channel out signal <b>outDepth </b>can look like [3, [7, 18], [2, 5, 6]].</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Then out[1] is a three-channel signal, whereby out[1][0] corresponds to out[i-1] of the</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>first, out[1][1] to out[i-18] of the second and out[1][2] to out[i-5] of the third component.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If the size of <b>inDepth </b>/ <b>outDepth </b>is smaller than <b>outSize</b>, wrapping is applied.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>As a result double-bracketing can be used to define specific lookback indices</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for all components of the multichannel signal:</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>E.g. if <b>outDepth </b>equals [[7, 18]] for a three-channel signal then out[0] means<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the three-channel signal out[i-7] and out[1] means out[i-18].</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>See Ex. 3a for multichannel feedback / feedforward.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>in </b>- A single ar input signal or a SequenceableCollection of ar input signals to be referred to<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>with <b>func</b> (feedforward data). <b><span class="Apple-tab-span">	</span></b>See Ex. 3a for multichannel feedback / feedforward.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>outSize </b>- Integer or SequenceableCollection thereof,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the size(s) defined by the UGen(s) returned by <b>func</b>.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>It's the user's responsibilty to pass the correct size(s)!<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 0.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>inDepth </b>- Integer or SequenceableCollection of Integers or SequenceableCollections thereof,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this determines the behaviour of <b>func </b>(see there).</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an Integer is passed, it means the maximum storage size for feedforward data.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a SequenceableCollection is passed, lookback indices for feedforward data<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>can be differentiated, its items can again be Integers or SequenceableCollections (see <b>func</b>).<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Usually the inner SequenceableCollections should be ordered, but this is not compulsory.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1 (no lookback). See Ex. 3c.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>outDepth </b>- Integer or SequenceableCollection of Integers or SequenceableCollections thereof,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>this determines the behaviour of <b>func </b>(see there).</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If an Integer is passed, it means the maximum storage size for feedback data.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a SequenceableCollection is passed, lookback indices for feedback data<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>can be differentiated, its items can again be Integers or SequenceableCollections (see <b>func</b>).<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Usually the inner SequenceableCollections should be ordered, but this is not compulsory.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 2 (look back to last sample at maximum). See Ex. 3c.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>inInit </b>- Number or SequenceableCollection, feedforward init data.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a Number is passed, it means the previous init value for the calculation of the first sample(s),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if the size of <b>in </b>is larger than 1, this init value is taken for all components of the multichannel signal.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a SequenceableCollection is passed, this differentiates the init values<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for a multichannel signal 'in' used by <b>func</b>. Then the components must be Numbers<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(again defining one init value) or SequenceableCollections, which</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>define a lookback collection: first Number is the previous value, second the value before and so on.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If the size of <b>inInit</b> is smaller than the size of<b> in, </b>wrapping is applied, that way a double-bracket array,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>e.g. [[3, 0, 1]], defines the same init sequence for all components of a multichannel <b>in</b>. See Ex. 3b.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>outInit </b>- Number or SequenceableCollection, feedback init data.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a Number is passed, it means the previous init value for the calculation of the first sample(s),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if <b>outSize </b>is larger than 1, this init value is taken for all components of the<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>multichannel signal 'out' used by <b>func</b>.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If a SequenceableCollection is passed, this differentiates the init values<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for this multichannel signal. Then the components must be Numbers (again defining one init value)<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>or SequenceableCollections, which define a lookback collection:<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>first Number is the previous value, second the value before and so on.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If the size of <b>outInit</b> is smaller than <b>outSize, </b>wrapping is applied, that way a double-bracket array,<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>e.g. [[3, 0, 1]], defines the same init sequence for all components of the multichannel signal<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>'out' used by <b>func</b>. See Ex. 3b.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>blockSize </b>- Integer, this should be the server blockSize. It's the user's responsibility to pass</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the correct number. However it might be interesting to experiment with other values.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 64. See Ex. 3d.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>blockFactor </b>- Integer. For a value &gt; 1 this allows for lookback indices larger than <b>blockSize</b>, up to<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>blockSize </b>*<b> blockFactor </b>- 1. It's the user's responsibility to pass correct Integers in this case.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to 1. See Ex. 3d.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>graphOrderType </b>- 0, 1 or 2.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Determines if topological order of generated BufRd and BufWr instances</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in the SynthDef graph is forced by additional UGens.<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Type 0: forced graph order is turned off.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Type 1 (default): graph order is forced by summation and &lt;!.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Type 2: graph order is forced by &lt;! operators only.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Default 1 is recommended, but with CPU-intense SynthDefs it might be worth trying it with the value 0.<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>This saves a lot of UGens and in all my examples I didn't encounter cases with different results.<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Type 2 can shorten the SynthDef compilation time for certain graphs with a large number of UGens,</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>which can be lengthy with type 1.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>However, CPU usage doesn't directly correspond to the number of UGens.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>leakDC </b>- Boolean. Determines if a LeakDC is applied to the output.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to true.</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>leakCoef </b>- Number, the <b>leakDC </b>coefficient. Defaults to 0.995.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-converted-space"> <span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span></p>
<p class="p8"><br></p>
<p class="p8"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p11"><b>Overview - what can / cannot be done ?</b></p>
<p class="p12"><br></p>
<p class="p13">// What can be done:</p>
<p class="p4"><br></p>
<p class="p13">// The feedback / feedforward relation is defined within func,</p>
<p class="p13">// it's important to note that this Function is applied in a very special way</p>
<p class="p13">// to build the feedback relation into the synthdef graph.</p>
<p class="p14"><br></p>
<p class="p13">// Let n be the given blockSize, then</p>
<p class="p4"><br></p>
<p class="p13">// 1.) <span class="Apple-tab-span">	</span>func is applied n times to establish the iteration in the synthdef graph.</p>
<p class="p13">// 2.)<span class="Apple-tab-span">	</span>func (only formally) takes over previous (multichannel) samples for calculation of</p>
<p class="p13">//<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>next (multichannel) samples via 'out' arg,</p>
<p class="p13">//<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>technically BufRd.krs are passed to 'out' arg, the ar signals are reconstructed thereafter</p>
<p class="p13">// 3.) <span class="Apple-tab-span">	</span>unary and binary operators are the basic tools for this calculation</p>
<p class="p13">// 4.) <span class="Apple-tab-span">	</span>func can take over modulating kr UGens from outside via simple reference,</p>
<p class="p13">//<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>no linear interpolation in this case though, you might therefore consider (5)</p>
<p class="p13">// 5.) <span class="Apple-tab-span">	</span>func can take over modulating ar UGens from outside via Fb1's and func's 'in' arg</p>
<p class="p13">// 6.)<span class="Apple-tab-span">	</span>func can contain explicitely defined kr UGens,</p>
<p class="p13">//<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>note that for every UGen in func, n instances are built into the SynthDef graph!</p>
<p class="p13">// 7.) <span class="Apple-tab-span">	</span>kr UGens in func can be applied to data passed via 'in' or 'out'</p>
<p class="p13">// 8.)<span class="Apple-tab-span">	</span>func's index argument can be used to specify the feedback / feedforward relation per block index</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// What cannot / shouldn't be done</p>
<p class="p4"><br></p>
<p class="p13">// Writing ar UGens in func that produce a time-varying signal itself</p>
<p class="p13">// (e.g. SinOsc.ar, in contrast to SinOsc.kr and operator UGens like '+', '*' etc.) -</p>
<p class="p13">// instead, if such ar UGens aren't applied to data from inside func,<span class="Apple-converted-space"> </span></p>
<p class="p13">// they can be passed via Fb1's and func's 'in' arg.</p>
<p class="p13">// It remains the case of such ar UGens that should process data that is provided by func</p>
<p class="p13">// (e.g. letting the fb out modulate a parameter of a VarSaw.ar).<span class="Apple-converted-space"> </span></p>
<p class="p13">// This is currently not possible<span class="s2"> </span>and I don't have a clear picture if and how<span class="Apple-converted-space"> </span></p>
<p class="p13">// it would be possible at all or if it would make much sense.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p12"><br></p>
<p class="p11"><b>Examples 1) Proof of concept</b></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">s = <span class="s6">Server</span>.local;</p>
<p class="p15"><span class="s6">Server</span>.default = s;</p>
<p class="p15">s.boot;</p>
<p class="p15">)</p>
<p class="p14"><br></p>
<p class="p13">// Examples 1b-1d are just a comparison of standard filters vs. explicit definition with Fb1</p>
<p class="p13">// to show its functioning.</p>
<p class="p13">// Mostly there is no benefit in doing so in practice as standard filters UGens need less ressources.</p>
<p class="p13">// The real power of Fb1 lies in the potential to define nonlinear feedback and feedforward relations (2a-2f).</p>
<p class="p13">// Other than that you can use it to define higher order linear filters for which no classes exist.</p>
<p class="p14"><br></p>
<p class="p13">// check blockSize before</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">if (s.options.blockSize != 64) {</p>
<p class="p15"><span class="Apple-tab-span">	</span>s.options.blockSize = 64;</p>
<p class="p15"><span class="Apple-tab-span">	</span>s.quit.reboot;</p>
<p class="p15">}</p>
<p class="p15">)</p>
<p class="p12"><br></p>
<p class="p11"><b>Ex.1a) Basic principle</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// The original form of the following example is by Nathaniel Virgo<span class="Apple-converted-space"> </span></p>
<p class="p13">// and shows the underlying principle for feedback alone<span class="s2">.</span></p>
<p class="p13">// Succesively Buffers are set with new values at kr,</p>
<p class="p13">// at the end buffers are read with an ar Phasor,</p>
<p class="p13">// thereby the order of UGens is crucial.</p>
<p class="p13">// As James Harkins remarked in the below thread,</p>
<p class="p13">// plugging the writers into the final reader forces it,</p>
<p class="p13">// it can be done with summing, but other operations than '+' are also possible.</p>
<p class="p4"><br></p>
<p class="p13">// The example also works without this precautionary measure, at least on OSX, SC 3.9.3.</p>
<p class="p13">// The option graphOrderType allows to turn forced ordering off or to choose an</p>
<p class="p13">// alternative order-forcing operation, see Ex. 4.</p>
<p class="p4"><br></p>
<p class="p13">// https://www.listarc.bham.ac.uk/lists/sc-users-2011/msg01337.html</p>
<p class="p13">// https://www.listarc.bham.ac.uk/lists/sc-users-2011/msg01363.html</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> buf1 = <span class="s6">LocalBuf</span>(64);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> buf2 = <span class="s6">LocalBuf</span>(64);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> x1, x2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> writer_1 = <span class="s6">DC</span>.ar(0);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> writer_2 = <span class="s6">DC</span>.ar(0);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">SetBuf</span>(buf1, [1], 63);<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">SetBuf</span>(buf2, [0], 63);</p>
<p class="p15"><span class="Apple-tab-span">	</span>x1 = <span class="s6">BufRd</span>.kr(1, buf1, 63);</p>
<p class="p15"><span class="Apple-tab-span">	</span>x2 = <span class="s6">BufRd</span>.kr(1, buf2, 63);</p>
<p class="p15"><span class="Apple-tab-span">	</span>64.do { <span class="s6">|</span>i|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x1 = x1 + (0.2 * x2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x2 = tanh(x2 * 1.2 - (0.1 * x1));</p>
<p class="p4"><br></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>writer_1 = writer_1 + <span class="s6">BufWr</span>.kr(x1, buf1, i);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>writer_2 = writer_2 + <span class="s6">BufWr</span>.kr(x2, buf2, i);</p>
<p class="p15"><span class="Apple-tab-span">	</span>};</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// '&lt;!' ensures that BufWrs are placed before the final reader</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">BufRd</span>.ar(1, [buf1 &lt;! writer_1, buf2 &lt;! writer_2], <span class="s6">Phasor</span>.ar(0, 1, 0, 64)) * 0.1;</p>
<p class="p15">}.play;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// same written with Fb1</p>
<p class="p13">// per default LeakDC is applied, turn off here</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y = {</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span></span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">var</span><span class="s2"> x1, x2; </span>// define variables to adapt naming convention of above</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// refer to last out samples</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>#x1, x2 = out[1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x1 = x1 + (0.2 * x2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x2 = tanh(x2 * 1.2 - (0.1 * x1));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[x1, x2]</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, outSize: 2, outInit: [1, 0], leakDC: <span class="s6">false</span>) * 0.1</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// check if it's really the same, the difference should run silently (Fb1 without LeakDC)</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">z = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> buf1 = <span class="s6">LocalBuf</span>(64);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> buf2 = <span class="s6">LocalBuf</span>(64);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> x1, x2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> writer_1 = <span class="s6">DC</span>.ar(0);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> writer_2 = <span class="s6">DC</span>.ar(0);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">SetBuf</span>(buf1, [1], 63);<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">SetBuf</span>(buf2, [0], 63);</p>
<p class="p15"><span class="Apple-tab-span">	</span>x1 = <span class="s6">BufRd</span>.kr(1, buf1, 63);</p>
<p class="p15"><span class="Apple-tab-span">	</span>x2 = <span class="s6">BufRd</span>.kr(1, buf2, 63);</p>
<p class="p4"><br></p>
<p class="p15"><span class="Apple-tab-span">	</span>64.do { <span class="s6">|</span>i|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x1 = x1 + (0.2 * x2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x2 = tanh(x2 * 1.2 - (0.1 * x1));</p>
<p class="p4"><br></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>writer_1 = writer_1 + <span class="s6">BufWr</span>.kr(x1, buf1, i);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>writer_2 = writer_2 + <span class="s6">BufWr</span>.kr(x2, buf2, i);</p>
<p class="p15"><span class="Apple-tab-span">	</span>};</p>
<p class="p4"><span class="Apple-tab-span">	</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">BufRd</span>.ar(1, [buf1 &lt;! writer_1, buf2 &lt;! writer_2], <span class="s6">Phasor</span>.ar(0, 1, 0, 64)) -</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">var</span><span class="s2"> x1, x2; </span>// define variables to adapt naming convention of above</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>#x1, x2 = out[1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x1 = x1 + (0.2 * x2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>x2 = tanh(x2 * 1.2 - (0.1 * x1));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[x1, x2]</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, outSize: 2, outInit: [1, 0], leakDC: <span class="s6">false</span>) * 0.1;</p>
<p class="p15">}.play;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">z.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.1b) OnePole</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// OnePole as lopass</p>
<p class="p4"><br></p>
<p class="p15">s.freqscope;</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">OnePole</span>.ar(<span class="s6">WhiteNoise</span>.ar(0.3), 0.95) }.play;</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p13">// OnePole is implemented by out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1))</p>
<p class="p13">// so it can be written with Fb1</p>
<p class="p4"><br></p>
<p class="p15">y = { <span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in[0] * 0.05) + (out[1] * 0.95) }, <span class="s6">WhiteNoise</span>.ar(0.3), leakDC: <span class="s8">false</span>) }.play</p>
<p class="p4"><br></p>
<p class="p15">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// difference check: this falls silent (Fb1 without LeakDC)</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">z = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar(0.5);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in[0] * 0.05) + (out[1] * 0.95) }, src, leakDC: <span class="s8">false</span>) - <span class="s6">OnePole</span>.ar(src, 0.95)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">z.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// stereo case: 'in' is passed a stereo noise,</p>
<p class="p13">// in addition we have to pass outSize: 2,</p>
<p class="p13">// then the Function can be written in the same way</p>
<p class="p13">// in[0] and out[1] now mean stereo signals</p>
<p class="p4"><br></p>
<p class="p15">u = { <span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in[0] * 0.05) + (out[1] * 0.95) }, <span class="s6">WhiteNoise</span>.ar(0.3!2), 2) }.play</p>
<p class="p4"><br></p>
<p class="p15">u.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// difference check with dynamic coefficient</p>
<p class="p13">// pass the ar signal via Fb1's 'in' arg</p>
<p class="p13">// difference nearly 0, even with fast modulation</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">v = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar(0.5);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod = <span class="s6">LFDNoise3</span>.ar(50).range(0.7, 0.99);</p>
<p class="p15"><span class="Apple-tab-span">	</span>(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> src, mod;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>#src, mod = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(src * (1 - mod)) + (out[1] * mod)<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [src, mod], leakDC: <span class="s8">false</span>) -</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">OnePole</span>.ar(src, mod)</p>
<p class="p15"><span class="Apple-tab-span">	</span>).poll</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">v.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// Now check same with kr signal for coefficient,</p>
<p class="p13">// here we can directly take over the signal in func,</p>
<p class="p13">// difference is not zero though, because OnePole</p>
<p class="p13">// does linear interpolation with mod (Fb1 doesn't)!</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">w = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar(0.5);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod = <span class="s6">LFDNoise3</span>.kr(50).range(0.7, 0.99);</p>
<p class="p15"><span class="Apple-tab-span">	</span>(</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in[0] * (1 - mod)) + (out[1] * mod) }, src, leakDC: <span class="s8">false</span>) -</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">OnePole</span>.ar(src, mod)</p>
<p class="p15"><span class="Apple-tab-span">	</span>).poll</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">w.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// proof of concept with kr:</p>
<p class="p13">// If OnePole doesn't interpolate (as with Latch),</p>
<p class="p13">// signals are the same</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">q = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">WhiteNoise</span>.ar(0.5);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod = <span class="s6">LFDNoise3</span>.kr(50).range(0.7, 0.99);</p>
<p class="p15"><span class="Apple-tab-span">	</span>(</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in[0] * (1 - mod)) + (out[1] * mod) }, src, leakDC: <span class="s8">false</span>) -</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">OnePole</span>.ar(src, <span class="s6">Latch</span>.ar(mod, <span class="s6">TDuty</span>.ar(<span class="s6">ControlDur</span>.ir)))</p>
<p class="p15"><span class="Apple-tab-span">	</span>).poll</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">q.release</p>
<p class="p14"><br></p>
<p class="p5"><span class="s9"><br>
</span><b>Ex.1c) SOS</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// SOS as bandreject, note its convention:</p>
<p class="p13">// SOS.ar(in, a0, a1, a2, b1, b2, mul, add)</p>
<p class="p13">// out(i) = (a0 * in(i)) + (a1 * in(i-1)) + (a2 * in(i-2)) + (b1 * out(i-1)) + (b2 * out(i-2))</p>
<p class="p4"><br></p>
<p class="p15">s.freqscope;</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">var</span><span class="s2"> a = [-0.6, 0.5, -0.7]; </span>// feedforward coefficients a0, a1, a2</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">var</span><span class="s2"> b = [0.5, -0.1]; </span>// feedback coefficients b1, b2</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">Saw</span>.ar(200, 0.1);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">SOS</span>.ar(src, *(a ++ b))</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p13">// written with Fb1</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> a = [-0.6, 0.5, -0.7];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> b = [0.5, -0.1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">Saw</span>.ar(200, 0.1);</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// out[0] (= out[i-blockSize]) is passed formally to allow taking over the usual index convention</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// here we drop it as b1 = b[0] and b2 = b[1]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// as we look back two samples for feedforward and feedback we need to pass depths 3</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in * a).sum + (out.drop(1) * b).sum }, src, 0, 3, 3, leakDC: <span class="s8">false</span>)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// difference check: this falls silent</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">z = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> a = [-0.6, 0.5, -0.7];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> b = [0.5, -0.1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">Saw</span>.ar(200, 0.1);</p>
<p class="p15"><span class="Apple-tab-span">	</span>(</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in * a).sum + (out.drop(1) * b).sum }, src, 0, 3, 3, leakDC: <span class="s8">false</span>) -</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">SOS</span><span class="s2">.ar(src, *(a ++ b)) </span>// '*' splits the array into single items needed as UGen args</p>
<p class="p15"><span class="Apple-tab-span">	</span>).poll<span class="Apple-converted-space"> </span></p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">z.release</p>
<p class="p14"><br></p>
<p class="p14"><br></p>
<p class="p5"><b>Ex.1d) LTI</b></p>
<p class="p13"><span class="s2"><br>
</span>// You need to have the SC-3 plugins installed in order to use LTI,</p>
<p class="p13">// which is part of Nick Collins' SLUGens.</p>
<p class="p4"><br></p>
<p class="p13">// Example with coefficients from Nick Collins' helpfile,</p>
<p class="p13">// here 'a' is used for feedback coefficients.</p>
<p class="p4"><br></p>
<p class="p13">// LTI needs data in buffers</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p13"><span class="s2">a = [0.02, -0.01]; </span>// feedback coefficients</p>
<p class="p15">b = [1, 0.7, 0, 0, 0, 0, -0.8, 0, 0, 0, 0, 0.9] ++</p>
<p class="p15"><span class="Apple-tab-span">	</span>[0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.25, 0.1, 0.25]; <span class="s10">// feedforward coefficients</span></p>
<p class="p15">c = <span class="s6">Buffer</span>.sendCollection(s, a, 1);</p>
<p class="p15">d = <span class="s6">Buffer</span>.sendCollection(s, b, 1);</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">LTI</span>.ar(<span class="s6">Saw</span>.ar(50, 0.1), c.bufnum, d.bufnum) }.play</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// Because of the large inDepth (25 !) a straight takeover of data is very CPU-demanding with Fb1</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">Saw</span>.ar(50, 0.1);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in * b).sum + (out.drop(1) * a).sum }, src, 0, b.size, 3, leakDC: <span class="s8">false</span>)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// This is an example, where passing lookback indices as depth arg helps a lot (more than 1000 UGens less!)</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">z = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">Saw</span>.ar(50, 0.1);</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s7">var</span><span class="s2"> ff = b.reject(</span><span class="s6">_</span><span class="s2"> == 0); </span>// [1, 0.7, -0.8, 0.9, -0.5, 0.25, 0.1, 0.25]</p>
<p class="p14"><span class="Apple-tab-span">	</span></p>
<p class="p13"><span class="Apple-tab-span">	</span>// for SC &lt; 3.7 you can write (0..b.size-1).select { |i| b[i] != 0 }</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> indices = b.selectIndices(<span class="s6">_</span> != 0); <span class="s10">// [0, 1, 6, 11, 15, 22, 23, 24]</span></p>
<p class="p14"><span class="Apple-tab-span">	</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Fb1</span>({ <span class="s7">|in, out|</span> (in * ff).sum + (out.drop(1) * a).sum }, src, 0, [indices], 3, leakDC: <span class="s8">false</span>)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">z.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// difference check, run silently</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">u = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> src = <span class="s6">Saw</span>.ar(50, 0.1);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> ff = [1, 0.7, -0.8, 0.9, -0.5, 0.25, 0.1, 0.25];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> indices = [0, 1, 6, 11, 15, 22, 23, 24];</p>
<p class="p15"><span class="Apple-tab-span">	</span>(<span class="s6">Fb1</span>({ <span class="s6">|in, out|</span> (in * ff).sum + (out.drop(1) * a).sum }, src, 0, [indices], 3, leakDC: <span class="s6">false</span>) -</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">LTI</span>.ar(src, c.bufnum, d.bufnum)).poll</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">u.release</p>
<p class="p4"><br></p>
<p class="p13">// The filter alternatives with Fb1 mainly make sense in the higher order case when coefficients should be modulated<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p5"><span class="s5"><br>
</span><b>Examples 2) Nonlinear feedback operations</b></p>
<p class="p4"><br></p>
<p class="p13">// This is an interesting field of exploration as it cannot easily be done with SC otherwise.</p>
<p class="p13">// Here the time-varying potential of unary and binary operators comes into play,</p>
<p class="p13">// normally they are applied to time-varying signals, but here their iteration on a</p>
<p class="p13">// single-sample base is itself an essential part of producing the variation in time.</p>
<p class="p13">// Good candidates are already simple operators and their combinations, also with + and -,<span class="Apple-converted-space"> </span></p>
<p class="p13">// e.g. *, /, **, %, trigonometric operators etc.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p5"><b>Ex.2a) %</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// start fb fx Synth</p>
<p class="p15"><br>
(</p>
<p class="p15"><span class="s11">~bus</span> = <span class="s6">Bus</span>.audio(s, 2);</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">In</span>.ar(<span class="s11">~bus</span>, 2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">SinOsc</span>.ar(0.1).linexp(-1, 1, 50, 500);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[2] * 0.7) + </span>// factors &gt; 1 blow up !</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// only the next line is limited with softclip</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][0] is the current stereo signal from the bus</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[1][0] is the previous</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][1] is the current mono lfo, passed with the 'in' arg</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// func returns a stereo signal, so outSize must be passed 2</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// inDepth [2, 1] because we use inSig[0], inSig[1] and lfo[0]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outDepth 3 because we use out[2]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// note that it would be cheaper to use out[0] and outDepth: [[2]],</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// but a bit more difficult to read</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>((in[0][0] - in[1][0]) % 0.01 * in[0][1]).softclip</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, lfo], 2, [2, 1], 3</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.1</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p13">// start source</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">SinOsc</span>.ar([60, 60.1]) * <span class="s6">EnvGate</span>.new) }.play</p>
<p class="p4"><br></p>
<p class="p13">// stop source and start new one</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">Saw</span>.ar(<span class="s6">SinOsc</span>.ar(0.07).linlin(-1, 1, [100, 100.01], 100.2) * <span class="s6">EnvGate</span>.new)) }.play</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y.free;</p>
<p class="p15"><span class="s11">~bus</span>.free;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2b) sin</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// sin can work as a limiter as well as a nonlinear dynamics engine,</p>
<p class="p13">// here it causes a wavefolding-like effect</p>
<p class="p14"><br></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// start fb fx Synth</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15"><span class="s11">~bus</span> = <span class="s6">Bus</span>.audio(s, 1);</p>
<p class="p4"><br></p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">In</span>.ar(<span class="s11">~bus</span>);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">SinOsc</span>.ar(0.1, -pi/2).linexp(-1, 1, [5, 10], 100) * 100;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// here out[0] refers to out[i-2] because of outDepth: [[2]]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[0] * 0.7) + </span>// factors &gt; 1 blow up !</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// here in[0][0] and in[1][0] are current and previous mono inSig,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// but in[0][1] is stereo, so again a stereo signal is returned by func,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// which must be indicated with the outSize arg</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>((in[0][0] - in[1][0]) * in[0][1]).sin</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig,<span class="Apple-converted-space">  </span>lfo], 2, [2, 1], [[2]]</p>
<p class="p15"><span class="Apple-tab-span">	</span>) * 0.05, 15000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// start source</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">SinOsc</span>.ar(60) * <span class="s6">EnvGate</span>.new) }.play;</p>
<p class="p4"><br></p>
<p class="p15">x.release;</p>
<p class="p4"><br></p>
<p class="p13">// stop source and start new one</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">Saw</span>.ar(<span class="s6">SinOsc</span>.ar(0.05).linlin(-1, 1, 100, 100.02) * <span class="s6">EnvGate</span>.new)) }.play</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y.free;</p>
<p class="p15"><span class="s11">~bus</span>.free;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2c) *<span class="Apple-converted-space"> </span></b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// rather irrational concatenation of simple operations</p>
<p class="p13">// depth changes cause frequency changes</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// start fb fx Synth</p>
<p class="p15"><br>
(</p>
<p class="p15"><span class="s11">~bus</span> = <span class="s6">Bus</span>.audio(s, 1);</p>
<p class="p4"><br></p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">In</span>.ar(<span class="s11">~bus</span>);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = { <span class="s6">LFDNoise3</span>.ar(0.07).linexp(-1, 1, 1, 5) } ! 2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> i = <span class="s6">Demand</span>.kr(<span class="s6">Dust</span>.kr(0.5), 0, <span class="s6">Dxrand</span>((0..2), <span class="s8">inf</span>));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in[0][1] * (</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in[0][0] * 0.12 + (</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// changes between out[i-23], out[i-41] and out[i-60] cause frequency changes,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// Select depends on a signal from outside, not previous samples as in Ex. 2f</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(in[1][0].squared - <span class="s6">Select</span>.kr(i, out).squared).sqrt</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>)</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>)<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, [inSig, lfo], 2, [2, 1], [[23, 41, 60]]) * 0.1;</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// add frequency modulation by delay modulation</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// lopass filtering with lag</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">DelayC</span>.ar(sig, 0.2, <span class="s6">LFDNoise3</span>.ar(1).range(0.01, 0.1)).lag(0.0005)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p13">// start source</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">LFTri</span>.ar(<span class="s6">LFDNoise0</span>.ar(5).exprange(1, 100)) * <span class="s6">EnvGate</span>.new) }.play;</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y.free;</p>
<p class="p15"><span class="s11">~bus</span>.free;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2d) /<span class="Apple-converted-space"> </span></b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><br></p>
<p class="p13">// With divisions we must avoid division by zero resp. blowup, here it's max in the divisor.</p>
<p class="p13">// The example also establishes a cross-feedback of the two channels by using reverse.</p>
<p class="p4"><br></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// start fb fx Synth</p>
<p class="p15"><br>
(</p>
<p class="p15"><span class="s11">~bus</span> = <span class="s6">Bus</span>.audio(s, 2);</p>
<p class="p4"><br></p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">In</span>.ar(<span class="s11">~bus</span>, 2);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">LFDNoise3</span>.ar(1).linexp(-1, 1, 0.2, 10);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(in[1][0] * in[0][1] / max(0.001, (in[1][0] - out[1].reverse).abs)).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, lfo], 2, [2, 1], 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.1</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p13">// start source</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(<span class="s11">~bus</span>, <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1!2).range(100, 101)) * <span class="s6">EnvGate</span>.new) }.play</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y.free;</p>
<p class="p15"><span class="s11">~bus</span>.free;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p18"><br></p>
<p class="p11"><b>Ex.2e) **</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// exponentiation can also be interesting</p>
<p class="p13">// here an area of instability is crossed by a stereo lfo<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// start fb fx Synth</p>
<p class="p15"><br>
(</p>
<p class="p15">~bus = <span class="s6">Bus</span>.audio(s, 1);</p>
<p class="p4"><br></p>
<p class="p15">y = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> inSig = <span class="s6">In</span>.ar(~bus);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> lfo = { <span class="s6">LFDNoise3</span>.ar(0.5).linexp(-1, 1, 0.1, 150) } ! 2;</p>
<p class="p4"><br></p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span></span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in[1][0] * 0.07 +</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// out[0] refers to out[i-2] because of outDepth: [[2]]</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(2 ** (in[1][0] - out[0] * in[0][1]).abs).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, [inSig, lfo], 2, [2, 1], [[2]]) *</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// avoid bump at start<span class="Apple-converted-space"> <span class="Apple-tab-span">	</span></span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">EnvGen</span>.ar(<span class="s6">Env</span>.asr(2))</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// start source</p>
<p class="p4"><br></p>
<p class="p15">x = { <span class="s6">Out</span>.ar(~bus, <span class="s6">LFTri</span>.ar(60) * <span class="s6">EnvGate</span>.new) }.play;</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">y.free;</p>
<p class="p15"><span class="s11">~bus</span>.free;</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p19"><br></p>
<p class="p11"><b>Ex.2f) Conditional feedback</b></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13">// defining the next sample depending on some characteristics of the previous one(s)</p>
<p class="p13">// This can be done with the if UGen and Select.</p>
<p class="p13">// 'if' doesn't support multichannel expansion, so take Select here</p>
<p class="p4"><br></p>
<p class="p15">s.scope</p>
<p class="p4"><br></p>
<p class="p13">// noisy texture with beeps</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">LFDNoise3</span>.ar(1, 0.1);</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// ar modulators to be passed (avoid annoying steady tone caused by kr)</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod1 = <span class="s6">LFDNoise3</span>.ar(1).range(0.01, 0.2);</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// already slight difference results in quite strong stereo decorrelation</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod2 = <span class="s6">LFDNoise3</span>.ar(1).range([0.0001, 0.0002],<span class="Apple-converted-space">  </span>0.0049);</p>
<p class="p4"><br></p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// give same names as above for better readability</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> src = in[0][0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> mod1 = in[0][1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> mod2 = in[0][2];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip(</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">Select</span>.kr(</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// as mod2 is stereo we get stereo expansion</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// and in turn different selections</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outDepth = [[1, 6]]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// so out[0] refers to out[i-1], out[1] to out[i-6]</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[0] % 0.005 &lt; mod2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[out[1].neg * mod1, out[0] * 0.1]</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>) + src + out[0]</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>)</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// lopass filtering with lag</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, [src, mod1, mod2], 2, 1, [[1, 6]]).lag(0.001) * 0.5</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p5"><b>Examples 3) Conventions and args</b></p>
<p class="p19"><br></p>
<p class="p11"><b>Ex.3a) Multichannel feedback / feedforward</b></p>
<p class="p19"><br></p>
<p class="p13">// in and out can be multichannel signals of arbitrary size or collections thereof,</p>
<p class="p13">// however arbitrary nesting is not supported,</p>
<p class="p13">// outSize arg has to be passed explicitely,</p>
<p class="p13">// size of in arg is taken over automatically.</p>
<p class="p13"><span class="s2"><br>
</span>// also mind the difference between size 0 and 1:</p>
<p class="p13">// with outSize of 1 or [0] Fb1 returns an array<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p13">// here out is of size 3, in of sizes [3, 0]</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.01 ! 3).range(100, 101)); <span class="s10">// 3 channel in signal</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">LFDNoise3</span>.ar(0.1).linexp(-1, 1, 0.2, 10);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][0] and in[1][0] represent current and previous 3 channel samples from inSig</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][1] represents current sample from lfo</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// rotate causes cross-feedback of 3 channels</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// with reverse only first and last would cross</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(in[1][0] * in[0][1] / max(0.001, (in[1][0] - out[1].rotate(1)).abs)).tanh</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outSize 3 has to be passed</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, lfo], 3, [2, 1], 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Splay</span>.ar(sig)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// again out is of size 3, in of sizes [3, 3]</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.01 ! 3).range(100, 101)); <span class="s10">// 3 channel in signal</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> mod = <span class="s6">SinOsc</span>.ar([1, 2.001, 3.999] * 120).linexp(-1, 1, 0.2, 10);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][0] and in[1][0] represent current and previous 3 channel samples from inSig</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][1] represents current 3 samples from mod</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// rotate causes cross-feedback of 3 channels</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// with reverse only first and last would cross</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(in[1][0] * in[0][1] / max(0.001, (in[1][0] - out[1].rotate(1)).abs)).tanh</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outSize has to be passed</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, mod], 3, [2, 1], 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.05;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">Splay</span>.ar(sig)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// it's also possible to let func return an array of (multichannel) signals,</p>
<p class="p13">// outSize must be set accordingly, here [2, 0],</p>
<p class="p13">// whereby the mono within the array is a "helper feedback"</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(1.5 ! 2).exprange(50, 100));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">LFDNoise3</span>.ar(5).linexp(-1, 1, 0.5, 100);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[1][0] represents previous 2 channel samples from inSig</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// in[0][1] represents current sample from lfo</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// reverse causes cross-feedback of 2 main channels</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// main feedback crosses with helper feedback</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// for main feedback use helper feedback<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1][1] / max(0.001, (in[1][0] - out[1][0].reverse).abs)).tanh,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// for helper feedback use first channel of main feedback</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1][0][0] + 0.1 / max(0.01, ((in[0][1].abs)))).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>]</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outSize [2, 0] has to be passed</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, lfo], [2, 0], [2, 1], 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 12000) * 0.2;</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// return main feedback</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig[0]</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// here 2 x stereo, outSize == [2, 2]</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// two stereo sources</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> in_1 = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1 ! 2).range(100, 101));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> in_2 = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1 ! 2).range(150, 151));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">LFDNoise3</span>.ar(0.1).linexp(-1, 1, 0.2, 10);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// rename for better readability</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// previous ins are stereo</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevIn_1 = in[1][0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevIn_2 = in[1][1];</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// mono lfo</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = in[0][2];</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// out is 2 x 2 (see below)</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevOut_1 = out[1][0]; <span class="s10">// stereo</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevOut_2 = out[1][1]; <span class="s10">// stereo</span></p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// we return an array of two stereo signals</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(prevIn_1 * lfo / max(0.001, (prevIn_1 - prevOut_1.reverse).abs)),</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(prevIn_2 * lfo / max(0.001, (prevIn_2 - prevOut_2.reverse).abs))</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>].tanh</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outSize [2, 2] has to be passed</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [in_1, in_2, lfo], [2, 2], 2, 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.05;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig[0] + sig[1]; <span class="s10">// mix together</span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// sig[0];</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// sig[1];</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// variant: cross feedback within first stereo out (a) plus</p>
<p class="p13">// cross feedback the stereo signals with each other (b)</p>
<p class="p4"><br></p>
<p class="p13">// at the end take only first stereo out</p>
<p class="p13">// because of (b) the 150 Hz of in_2 are contained in the resulting signal</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> in_1 = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1 ! 2).range(100, 101));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> in_2 = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1 ! 2).range(150, 151));</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">LFDNoise3</span>.ar(0.1).linexp(-1, 1, 0.2, 10);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// rename for better readability</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// previous ins are stereo</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevIn_1 = in[1][0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevIn_2 = in[1][1];</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// mono lfo</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = in[0][2];</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// out is 2 x 2 (see below)</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevOut_1 = out[1][0]; <span class="s10">// stereo</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> prevOut_2 = out[1][1]; <span class="s10">// stereo</span></p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// we return an array of two stereo signals</p>
<p class="p4"><br></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(prevIn_1 * lfo / max(0.001, (prevIn_1 - prevOut_2.reverse).abs)),</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(prevIn_2 * lfo / max(0.001, (prevIn_2 - prevOut_1).abs))</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>].tanh</p>
<p class="p4"><br></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// outSize has to be passed</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [in_1, in_2, lfo], [2, 2], 2, 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>), 15000) * 0.05;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig[0]</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p14"><br></p>
<p class="p19"><br></p>
<p class="p11"><b>Ex.3b) inInit / outInit</b></p>
<p class="p19"><br></p>
<p class="p4"><br></p>
<p class="p13">// linear congruential generator</p>
<p class="p4"><br></p>
<p class="p13">// this is not a strict linear congruential generator</p>
<p class="p13">// as the server doesn't know integers, it's done with floats,</p>
<p class="p13">// all is blurred by floating point inaccuracy</p>
<p class="p13">// however interesting results can be obtained</p>
<p class="p4"><br></p>
<p class="p13">// different start values can produce different orbits</p>
<p class="p4"><br></p>
<p class="p13">// WARNING: can produce loud high pitches with certain init values and factors</p>
<p class="p13">// as a result of short iteration cycles, take LPF !</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// same init value for both channels</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[1] * 5.239 % 1</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1 </span>// [1] is equivalent</p>
<p class="p15"><span class="Apple-tab-span">	</span>).tanh * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 2000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// other iteration sequence by different init value</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[1] * 5.239 % 1</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>).tanh * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 2000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// defining different init values per channel</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[1] * 5.239 % 1</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: [1, 2]</p>
<p class="p15"><span class="Apple-tab-span">	</span>).tanh * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 2000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// mono, two init values for one channel (previous and previous of previous)</p>
<p class="p13">// this needs double brackets for outInit</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[1] * 2 + (out[2] * 3) % 1.01</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 1,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: [[2, 6]],<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outDepth: 3 </span>// needed as we look back for 2 values</p>
<p class="p15"><span class="Apple-tab-span">	</span>).tanh * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 2000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// stereo, different arrays of init values per channel</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[1] * 2 + (out[2] * 3) % 1.01</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: [[3, 1], [2, 5]],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outDepth: 3<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>).tanh * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 2000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// inInit values can be defined in the same way as outInit</p>
<p class="p4"><br></p>
<p class="p13">// want a trigger at start in connection with Dust</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> trig = <span class="s6">Dust</span>.ar(0.3);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(1000);</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> tr = in[1][0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> mod = in[0][1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] + tr * (mod * 0.02 + 0.999999))</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: [trig, src],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: 2,</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// here both in buffers get init values, only the first is relevant</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inInit: 1,<span class="Apple-converted-space">  </span></span>// [1, 0] doesn't make a difference<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>).lag(0.005).tanh * 0.5;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p19"><br></p>
<p class="p13">// inInit and outInit cannot be differentiated for a multichannel component of a multichannel in / out.</p>
<p class="p13">// If you want to do such, you'd have to split the inner<span class="Apple-converted-space"> </span></p>
<p class="p13">// multichannel component and differentiate the outer one.<span class="Apple-converted-space"> </span></p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p11"><b>Ex.3c) inDepth / outDepth</b></p>
<p class="p19"><br></p>
<p class="p13">// Normally, and like in most previous examples,</p>
<p class="p13">// out[j] and in[j] in func refer to samples out[i-j] and in[i-j],</p>
<p class="p13">// in[0] to the current input samples.</p>
<p class="p13">// The lookback size can be determined by passing Integers to inDepth / outDepth, e.g.</p>
<p class="p13">// with inDepth = 2 you can refer to in[0] and in[i-1]</p>
<p class="p13">// with outDepth = 3 you can refer to out[i-1] and out[i-2],<span class="Apple-converted-space"> </span></p>
<p class="p13">// out[0] refers to out[i-blockSize].</p>
<p class="p4"><br></p>
<p class="p13">// When refering not to previous but to earlier samples,</p>
<p class="p13">// passing specified inDepth / outDepth indices is saving UGens.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// Here in[0] refers to in[0], the current sample(s), and</p>
<p class="p13">// in[1] refers to in[i-56].</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(500 * <span class="s6">LFDNoise3</span>.ar(5));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] / max(0.01, (in[1] - in[0]))).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: src,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: [[0, 56]],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1</p>
<p class="p15"><span class="Apple-tab-span">	</span>) ! 2 * 0.1 ;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// looking back less far changes the sound colour</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(500 * <span class="s6">LFDNoise3</span>.ar(5));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] / max(0.01, (in[1] - in[0]))).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: src,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: [[0, 29]],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1</p>
<p class="p15"><span class="Apple-tab-span">	</span>) ! 2 * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// differentiate inDepth per channel</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// stereo in</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(500 * <span class="s6">LFDNoise3</span>.ar(5!2));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] / max(0.01, (in[1] - in[0]))).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: src,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: [[0, 29], [0, 56]],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1</p>
<p class="p15"><span class="Apple-tab-span">	</span>) * [0.2, 0.1];</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p13">// inDepth and outDepth cannot be differentiated for a multichannel component of a multichannel in / out.</p>
<p class="p13">// If you want to do such, you'd have to split the inner<span class="Apple-converted-space"> </span></p>
<p class="p13">// multichannel component and differentiate the outer one.<span class="Apple-converted-space"> </span></p>
<p class="p18"><br></p>
<p class="p19"><br></p>
<p class="p11"><b>Ex.3d) blockSize / blockFactor</b></p>
<p class="p19"><br></p>
<p class="p13">// Normally Fb1's blockSize should equal the server's current blockSize,</p>
<p class="p13">// which can be set as a server option, per default it's 64.</p>
<p class="p4"><br></p>
<p class="p13">// If you are using a different blockSize, you can either<span class="Apple-converted-space"> </span></p>
<p class="p13">// reset it for the examples in this helpfile ...</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">if (s.options.blockSize != 64) {</p>
<p class="p15"><span class="Apple-tab-span">	</span>s.options.blockSize = 64;</p>
<p class="p15"><span class="Apple-tab-span">	</span>s.quit.reboot;</p>
<p class="p15">}</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p13">// ... or run the examples with passing a different blockSize, e.g. with:<span class="Apple-converted-space"> </span></p>
<p class="p4"><br></p>
<p class="p15"><span class="s6">Fb1</span>(..., blockSize: s.options.blockSize)</p>
<p class="p4"><br></p>
<p class="p18"><br></p>
<p class="p13">// You can however try to creativily use a "wrong" blockSize and play with artefacts,<span class="Apple-converted-space"> </span></p>
<p class="p13">// variant of Ex. 3c<span class="Apple-converted-space"> </span></p>
<p class="p18"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// stereo in</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(300 * <span class="s6">LFDNoise3</span>.ar(1!2));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] / max(0.01, (in[1] - in[0]))).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: src,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: [[0, 15], [0, 19]],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>blockSize: 33</p>
<p class="p15"><span class="Apple-tab-span">	</span>) * 0.2;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p13">// variant of Ex. 3c</p>
<p class="p13">// suppose a blockSize of 64, to look back to in[i-150] set blockFactor to 3.</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span></span>// stereo in</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> src = <span class="s6">SinOsc</span>.ar(500 * <span class="s6">LFDNoise3</span>.ar([0.3, 7]));</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>var<span class="s2"> sig = </span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(out[1] / max(0.001, (in[1] - in[0]))).distort</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>},</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outSize: 2,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in: src,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>inDepth: [[0, 150], [0, 29]],</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>outInit: 1,</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>blockFactor: 3</p>
<p class="p15"><span class="Apple-tab-span">	</span>) * [0.07, 0.15];</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p18"><br></p>
<p class="p18"><br></p>
<p class="p11"><b>Ex.3e) func index</b></p>
<p class="p19"><br></p>
<p class="p13">// func can take an index as third arg, it runs from 0 to blockSize - 1</p>
<p class="p13">// this can be used to define the feedback relation depending on it</p>
<p class="p19"><br></p>
<p class="p13">// note that inDepth is set to [2, 1] as we look back to inSig[i-1] (in[1][0]),</p>
<p class="p13">// but not to lfo[i-1] (in[0][1] == lfo[0]), this saves 128 UGens !</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> inSig = <span class="s6">SinOsc</span>.ar([50, 50.1]);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> lfo = <span class="s6">SinOsc</span>.ar(<span class="s6">LFDNoise3</span>.ar(0.1).range(0, 500)).range(0, [100, 105]);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out, i|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// establish alternating feedback relations in the synthdef graph</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>i.odd.if {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>in[0][0] * in[0][1] + out[1]<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}{</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(in[0][0] - in[1][0]) * out[1]</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>).tanh</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [inSig, lfo], 2, [2, 1], 2</p>
<p class="p15"><span class="Apple-tab-span">	</span>) * 0.1, 12000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p19"><br></p>
<p class="p19"><br></p>
<p class="p5"><b>Ex.4) Saving CPU</b></p>
<p class="p19"><br></p>
<p class="p13">// UGens written in func are generated as often as blockSize.</p>
<p class="p13">// Therefore, if possible, references to kr UGens outside save resources.</p>
<p class="p13">// In addition look for hidden unnecessary operations, which can add hundreds of UGens</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// 2440 UGens (with blockSize == 64)</p>
<p class="p13">// deliberately bad, deterministic lfo is generated blockSize times</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, src;</p>
<p class="p15"><span class="Apple-tab-span">	</span>src = <span class="s6">SinOsc</span>.ar(90 * <span class="s6">LFDNoise3</span>.ar(0.3!2).range(0.98, 1.02)) * <span class="s6">SinOsc</span>.ar(45.25);</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> b = out[1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> lfo = <span class="s6">SinOsc</span>.kr(<span class="s6">SinOsc</span>.kr(0.1).range(0.03, 1)).range(0.001, 0.01);</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip((a * a * a) + (a * a) + a + (a * a * b)<span class="Apple-converted-space">  </span>/ max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// 2188 UGens as (blockSize - 1) * 4 = 63 * 4 = 252 UGens are saved</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, src, lfo;</p>
<p class="p15"><span class="Apple-tab-span">	</span>src = <span class="s6">SinOsc</span>.ar(90 * <span class="s6">LFDNoise3</span>.ar(0.3!2).range(0.98, 1.02)) * <span class="s6">SinOsc</span>.ar(45.25);</p>
<p class="p15"><span class="Apple-tab-span">	</span>lfo = <span class="s6">SinOsc</span>.kr(<span class="s6">SinOsc</span>.kr(0.1).range(0.03, 1)).range(0.001, 0.01);</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> b = out[1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip((a * a * a) + (a * a) + a + (a * a * b)<span class="Apple-converted-space">  </span>/ max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// still bad though when looking at the the algebraic identity</p>
<p class="p13">// a^3 + a^2 + a + (a * a * b) = ((a + b) * a + a) * a + a</p>
<p class="p13">// these are 8 vs 5 operations, so with stereo we can save further<span class="Apple-converted-space"> </span></p>
<p class="p13">// ((8 - 5) * 2) * 64 = 384 UGens</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// 1804 UGens</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> sig, src, lfo;</p>
<p class="p15"><span class="Apple-tab-span">	</span>src = <span class="s6">SinOsc</span>.ar(90 * <span class="s6">LFDNoise3</span>.ar(0.3!2).range(0.98, 1.02)) * <span class="s6">SinOsc</span>.ar(45.25);</p>
<p class="p15"><span class="Apple-tab-span">	</span>lfo = <span class="s6">SinOsc</span>.kr(<span class="s6">SinOsc</span>.kr(0.1).range(0.03, 1)).range(0.001, 0.01);</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span>sig = </span>Fb1<span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">var</span> b = out[1];</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// with SC's L/R-precendence we can write without brackets</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip(a + b * a + a * a + a / max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// without forcing the topological order of BufRds and BufWrs further UGens are saved,</p>
<p class="p13">// this might or might not be the same result, might be distorted in worst case,</p>
<p class="p13">// however in all my tests I didn't encounter a single example where it was different</p>
<p class="p4"><br></p>
<p class="p13">// 1713 UGens</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig, src, lfo;</p>
<p class="p15"><span class="Apple-tab-span">	</span>src = <span class="s6">SinOsc</span>.ar(90 * <span class="s6">LFDNoise3</span>.ar(0.3!2).range(0.98, 1.02)) * <span class="s6">SinOsc</span>.ar(45.25);</p>
<p class="p15"><span class="Apple-tab-span">	</span>lfo = <span class="s6">SinOsc</span>.kr(<span class="s6">SinOsc</span>.kr(0.1).range(0.03, 1)).range(0.001, 0.01);</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">Fb1</span>({ <span class="s7">|in, out|</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> b = out[1];</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// with SC's L/R-precendence we can write without brackets</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip(a + b * a + a * a + a / max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2, graphOrderType: 0) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">// check if it's the same - run silently</p>
<p class="p4"><br></p>
<p class="p15">(</p>
<p class="p15">x = {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s7">var</span> sig, src, lfo;</p>
<p class="p15"><span class="Apple-tab-span">	</span>src = <span class="s6">SinOsc</span>.ar(90 * <span class="s6">LFDNoise3</span>.ar(0.3!2).range(0.98, 1.02)) * <span class="s6">SinOsc</span>.ar(45.25);</p>
<p class="p15"><span class="Apple-tab-span">	</span>lfo = <span class="s6">SinOsc</span>.kr(<span class="s6">SinOsc</span>.kr(0.1).range(0.03, 1)).range(0.001, 0.01);</p>
<p class="p15"><span class="Apple-tab-span">	</span>sig = <span class="s6">Fb1</span>({ <span class="s7">|in, out|</span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> b = out[1];</p>
<p class="p13"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// with SC's L/R-precendence we can write without brackets</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip(a + b * a + a * a + a / max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2, graphOrderType: 0) -</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s6">Fb1</span><span class="s2">({ </span>|in, out|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> a = in[0];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">var</span> b = out[1];</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>softclip(a + b * a + a * a + a / max(lfo, a + b));</p>
<p class="p15"><span class="Apple-tab-span">	</span>}, src, 2) * 0.1;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">LPF</span>.ar(sig, 3000)</p>
<p class="p15">}.play</p>
<p class="p15">)</p>
<p class="p4"><br></p>
<p class="p15">x.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
</body>
</html>
