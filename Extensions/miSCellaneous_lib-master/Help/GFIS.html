<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p5 {margin: 0.0px 0.0px 0.0px 27.0px; text-indent: -27.0px; font: 12.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p7 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica}
p.p9 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica}
p.p11 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
p.p16 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0433ff}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {text-decoration: underline ; color: #0000ee}
span.s5 {color: #0326cb}
span.s6 {color: #0433ff}
span.s7 {font: 9.0px Monaco}
span.s8 {color: #737373}
span.s9 {color: #008300}
span.s10 {color: #434ccb}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>GFIS<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>generalized functional iteration synthesis pseudo ugen</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="../miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p1"><b>Inherits from: UGen</b></p>
<p class="p4"><br></p>
<p class="p1">The GFIS class implements functional iteration synthesis as pseudo ugen loosely based on the description by Agostino Di Scipio ([1], [2]), who used the abbreviation FIS and pointed to its rich potential. Yari Marimoto has written a plugin implementation of the main sine-map iteration model, which is included in the trnsnd quark under the same name. The GFIS pseudo ugen implementation allows settings which go beyond functional iteration in a strict sense.<span class="Apple-converted-space"> </span></p>
<p class="p1">Principle idea of synthesis: given a parametrized non-linear function, time-variance of init values and/or parameter sets with fixed iteration depth n can produce interesting waveforms. Due to the highly non-linear dynamics involved, a great amount of unpredictability invites to experiment and exploration – depending on the characteristics of the time-varying signal, results span from brittle noisy textures to drones with rich spectral movements. The cited papers mainly describe strict iteration with sine and mention iterated waveshaping, but as the GFIS class implementation just takes an arbitrary Function it's easy to blur the concept, e.g. by altering the Function and/or the parametrization depending on the iteration level and/or applying iteration on multichannel signals, crossing their data etc. Also interesting – and probably not widely explored - is the use of functional iteration as controller / modulator / engine for other synthesis methods.</p>
<p class="p2"><br></p>
<p class="p1"><b>WARNING: </b>Be careful with amplitudes, in general higher numbers of iteration produce signals with more energy and due to the non-linear dynamics signals can suddenly become loud! Also go sure that your function doesn't allow blowup with iteration (this at least doesn't happen with the standard examples of the sine map model).<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p5">[1]<span class="Apple-tab-span">	</span>Di Scipio, Agostino (1999). "Synthesis Of Environmental Sound Textures by Iterated Nonlinear Functions" in: <i>Proceedings of the 2nd COST G-6 Workshop on Digital Audio Effects</i> (DAFx99), NTNU, Trondheim, December 9-11, 1999.</p>
<p class="p5">[2]<span class="Apple-tab-span">	</span>Di Scipio, Agostino (2001). "Iterated Nonlinear Functions as a Sound-Generating Engine" Leonardo, Vol. 34, No. 3 (2001), pp. 249-254, MIT Press.</p>
<p class="p2"><br></p>
<p class="p1"><b>See also: </b><a href="Fb1.html"><span class="s4">Fb1</span></a></p>
<p class="p2"><br></p>
<p class="p6"><b>Creation / Class Methods</b></p>
<p class="p7"><br></p>
<p class="p8"><b><span class="Apple-tab-span">	</span>*ar (func, init, n = 1, nOut, leakDC = true, leakCoef = 0.995)</b></p>
<p class="p9"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>func </b>- Function used to establish the iteration by applying it <b>n</b> times<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>at build time of the synthdef graph. The Function should take two arguments:<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the signal and an optional index. It should return the signal used for iteration.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The signal can be multichannel, then the Function might take that into account</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and refer to single channels of the signal arg - but the Function might also ignore<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>it and rely on multichannel expansion, see examples.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Note that UGens written within <b>func </b>are instantiated <b>n</b> times, this is usually</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>not what you want for iterating the same parametrical function, with determined</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>signals it's a waste of CPU and for random UGens the result is different.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>For the strict interpretation of FIS define the parameter signal outside and</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>refer to it from inside <b>func</b>.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>init </b>- Init value for the iteration, can also be a SequenceableCollection.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>n </b>- Integer, the maximum iteration number, it determines how often the Function</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>is used for building the synthdef graph, hence this value is not modulatable.<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nOut </b>- Integer or SequenceableCollection of Integers.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>An Integer determines the iteration level of the returned signal.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>That way you can define a maximum iteration number <b>n </b>and switch between</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>lower ones, however <b>n</b> iterations are permanently calculated.<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>In general switching will cause clicks, so this is an option for testing primarily.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>A SequenceableCollection of level indices will produce a</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>multichannel signal, which in turn allows defining smooth transitions</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>between signals of different iteration levels.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>leakDC </b>- Boolean. Determines if a LeakDC is applied to the output.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If the parameter signal doesn't change (which can e.g. happen with a LFDNoise UGen)<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>the result will in general be a DC offset, hence DC leaking is recommended.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to true.</p>
<p class="p10"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>leakCoef </b>- Number, the <b>leakDC </b>coefficient. Defaults to 0.995.</p>
<p class="p9"><br></p>
<p class="p8"><b><span class="Apple-tab-span">	</span>*kr (func, init, n = 1, nOut, leakDC = true, leakCoef = 0.995)</b></p>
<p class="p9"><br></p>
<p class="p9"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p11"><b>Examples</b></p>
<p class="p12"><br></p>
<p class="p13">(</p>
<p class="p13">s = <span class="s5">Server</span>.local;</p>
<p class="p13"><span class="s5">Server</span>.default = s;</p>
<p class="p13">s.boot;</p>
<p class="p13">)</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p11"><b>Examples 1) The sine map model</b></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p14">// These examples use an iterated sine map as described by Agostino Di Scipio.</p>
<p class="p14">// For the sine map sin(r * x) values of r varying between 2 and 4 are interesting.</p>
<p class="p14">// Driven by LFNoise parametrizations as in the first examples we get noise textures.</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.1a) Time-varying the factor r</b></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(10).range(3.5, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.3, 9) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// this is not "classical" FIS:</p>
<p class="p14">// for each iteration a different parametrization is taken !</p>
<p class="p14">// As LFDNoise UGens aren't coupled, pulsations are less unique</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(<span class="s5">LFDNoise3</span>.ar(10).range(3.5, 4) * x) }, 0.3, 9) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// less iterations</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(10).range(3.5, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.3, 7) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// different init value</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(10).range(3.5, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.85, 7) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// higher iteration gives sections with more high frequencies in the spectrum</p>
<p class="p14">// even higher numbers soon lead to (interrupted) white noise</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(3).range(3.5, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.3, 12) * 0.03 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// higher iteration numbers can partially be "equilibrated" with lower r</p>
<p class="p14">// this leads to different sounds, here a more "airy" noise</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(7).range(2.9, 3.1);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.3, 15) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// granular-like noise burst textures</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(50).range(2.5, 3);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, 0.3, 15) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p6"><span class="s7"><br>
</span><b>Ex.1b) Time-varying init values</b></p>
<p class="p4"><br></p>
<p class="p14">// mono</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> i = <span class="s5">LFDNoise3</span>.ar(7).range(0.2, 0.9);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(3.2 * x) }, i, 10) * 0.1 ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// stereo init is propagated to a stereo signal</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> i = <span class="s5">LFDNoise3</span>.ar(7).range(0.2, 0.9) * [1, 1.01];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(3.2 * x) }, i, 10) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p6"><b>Ex.1c) Time-varying init values and factor r</b></p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> i = <span class="s5">LFDNoise3</span>.ar(7).range(0.2, 0.9) * [1, 1.01];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> r = <span class="s5">LFDNoise3</span>.ar(2).range(3.2, 3.6) * [1, 1.01];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(r * x) }, i, 9) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p15"><br></p>
<p class="p6"><b>Ex.1d) Producing pitch by periodically oscillating parameters</b></p>
<p class="p4"><br></p>
<p class="p14">// variants of phase glitter</p>
<p class="p14">// note that here again the "lazy" FIS with different oscillators per iteration is used</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> osc = <span class="s5">SinOsc</span>.ar(30);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin((osc + <span class="s5">LFDNoise3</span>.ar(0.15)).linlin(-2, 2, 3.2, 4) * x) }, [0.5, 0.505], 9) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> osc = <span class="s5">SinOsc</span>.ar([30, 30.5]);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin((osc + <span class="s5">LFDNoise3</span>.ar(0.15)).linlin(-2, 2, 3.2, 4) * x) }, 0.5, 9) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> osc = <span class="s5">SinOsc</span>.ar([30, 30.5]);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin((osc + <span class="s5">LFDNoise3</span>.ar(0.15)).linlin(-2, 2, 3.2, 4) * x) }, [0.5, 0.505], 9) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// harmonics as different oscillation frequencies per iteration</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> oscMod = <span class="s5">SinOsc</span>.ar(0.1).range(30.01, 30.3);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x, i|</span><span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>sin((<span class="s5">SinOsc</span>.ar([30, oscMod] * (i+1)) + <span class="s5">LFDNoise3</span>.ar(0.15)).linlin(-2, 2, 3, 4) * x)<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span>}, [0.5, 0.502], 7) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// Pulse as oscillator</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> factors = <span class="s5">Demand</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">TDuty</span>.ar(<span class="s5">Dxrand</span>([4, 5, 7], <span class="s5">inf</span>)),<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0,<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">Dseq</span>([<span class="s5">Dseq</span>([1.3, 1.4], 2), 0.5], <span class="s5">inf</span>)</p>
<p class="p13"><span class="Apple-tab-span">	</span>).lag(0.7);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> osc = <span class="s5">Pulse</span>.ar([70, 70 * factors]).lag(0.001);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">LPF</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span><span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>sin((osc + <span class="s5">LFDNoise3</span>.ar(0.15)).linlin(-2, 2, 3.2, 4) * x)<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}, [0.5, 0.505], 9) * 0.1,</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>9000</p>
<p class="p13"><span class="Apple-tab-span">	</span>)</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Examples 2) The waveshaping model - iteration via buffered data</b></p>
<p class="p16"><br></p>
<p class="p15"><br></p>
<p class="p14">// a Buffer can be filled with an arbitrary mathematical function or audio data</p>
<p class="p4"><br></p>
<p class="p14">// load audio</p>
<p class="p4"><br></p>
<p class="p13">b = <span class="s5">Buffer</span>.read(s, <span class="s5">Platform</span>.miSCellaneousDirs[0] +/+ <span class="s8">"Sounds"</span> +/+ <span class="s8">"kitchen_sounds_1.wav"</span>);</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// load to array</p>
<p class="p4"><br></p>
<p class="p13">b.loadToFloatArray(action: { <span class="s6">|array|</span> a = array; <span class="s8">"done"</span>.postln });</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// take short snippet, normalize between 0 and 1</p>
<p class="p14">// that's most practical when we map to buffer index later on</p>
<p class="p15"><br></p>
<p class="p14">// the sound of the snippet is quite irrelevant</p>
<p class="p14">// more oscillations in general produce more noise with iteration</p>
<p class="p14">// start trying with sine-like forms</p>
<p class="p4"><br></p>
<p class="p13">d = a[3150..3300].normalize;</p>
<p class="p4"><br></p>
<p class="p13">d.plot;</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// fill new buffer for iteration</p>
<p class="p4"><br></p>
<p class="p13">c = <span class="s5">Buffer</span>.loadCollection(s, d)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2a) Time-varying init values</b></p>
<p class="p7"><br></p>
<p class="p14">// result of BufRd is used as index for the next BufRd</p>
<p class="p14">// needs Buffer c prepared above</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ <span class="s6">|x|</span> <span class="s5">BufRd</span>.ar(1, c, c.numFrames * x) },</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(<span class="s5">LFDNoise3</span>.ar(3) * [1, 1.1]).range(0.5, 0.51), 7</p>
<p class="p13"><span class="Apple-tab-span">	</span>) * 0.2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2b) Time-varying index deviation</b></p>
<p class="p4"><br></p>
<p class="p14">// needs Buffer c prepared above</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> add = <span class="s5">LFDNoise3</span>.ar(0.3) * [0.05, 0.0505];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ <span class="s6">|x|</span> <span class="s5">BufRd</span>.ar(1, c, c.numFrames * (x + add)) },<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.5, 7</p>
<p class="p13"><span class="Apple-tab-span">	</span>) * 0.2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.2c) Time-varying init values and index deviation</b></p>
<p class="p4"><br></p>
<p class="p14">// needs Buffer c prepared above</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> add = <span class="s5">LFDNoise3</span>.ar(0.3) * [0.05, 0.0505];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ <span class="s6">|x|</span> <span class="s5">BufRd</span>.ar(1, c, c.numFrames * (x + add)) },<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(<span class="s5">LFDNoise3</span>.ar(0.3) * [1, 1.01]).range(0.5, 0.505), 7</p>
<p class="p13"><span class="Apple-tab-span">	</span>) * 0.2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p11"><b>Examples 3) GFIS as controller / modulator / engine for other synthesis</b></p>
<p class="p15"><br></p>
<p class="p14">// this can transfer the instable characteristics to other sound worlds</p>
<p class="p15"><br></p>
<p class="p16"><br></p>
<p class="p11"><b>Ex.3a) FM<span class="Apple-converted-space"> </span></b></p>
<p class="p15"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> mod = <span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span> sin(<span class="s5">LFDNoise3</span>.ar(1).range(2.9, 4) * x) }, 0.3, 7);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">SinOsc</span>.ar(mod * [50, 51] * 70 + 300) * <span class="s5">LFDNoise3</span>.ar(2).range(0.2, 0.05)</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p6"><b>Ex.3b) Buffer modulation phase controlled by GFIS<span class="Apple-converted-space"> </span></b></p>
<p class="p15"><br></p>
<p class="p13">p = <span class="s5">Platform</span>.resourceDir +/+ <span class="s8">"sounds/a11wlk01.wav"</span>;</p>
<p class="p13">b = <span class="s5">Buffer</span>.read(s, p);</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s5">var</span><span class="s2"> pos = 0.5; </span>// other pos offset will give totally different sounds</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> osc = <span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span> sin(<span class="s5">LFDNoise3</span>.ar(10).range(3.2, 4) * x) }, 0.3, 6) * 0.1;</p>
<p class="p14"><span class="s2"><span class="Apple-tab-span">	</span></span>// GFIS involves a LeakDC, but not BufRd</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">LeakDC</span>.ar(<span class="s5">BufRd</span>.ar(1, b, b.numFrames * (osc * [0.0120, 0.0125] * 5 + pos), interpolation: 4)) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p16"><br></p>
<p class="p16"><br></p>
<p class="p11"><b>Ex.3c) Iterated GFIS<span class="Apple-converted-space"> </span></b></p>
<p class="p4"><br></p>
<p class="p14">// augmentation of non-linearity:</p>
<p class="p14">// GFIS itself used as time-varying control of another GFIS</p>
<p class="p4"><br></p>
<p class="p13">b = <span class="s5">Buffer</span>.read(s, <span class="s5">Platform</span>.miSCellaneousDirs[0] +/+ <span class="s8">"Sounds"</span> +/+ <span class="s8">"kitchen_sounds_1.wav"</span>);</p>
<p class="p4"><br></p>
<p class="p14">// load to array and fill new buffer for iteration</p>
<p class="p4"><br></p>
<p class="p13">b.loadToFloatArray(action: { <span class="s5">|array|</span> a = array; <span class="s8">"done"</span>.postln });</p>
<p class="p4"><br></p>
<p class="p13">d = a[3150..3300].normalize;</p>
<p class="p4"><br></p>
<p class="p13">c = <span class="s5">Buffer</span>.loadCollection(s, d);</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> r = <span class="s5">LFDNoise3</span>.ar(3).range(2.7, 3.4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> add = <span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span> sin(r * x) }, 0.5, 3) * [0.05, 0.055];</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar(</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{ <span class="s5">|x|</span> <span class="s5">BufRd</span>.ar(1, c, c.numFrames * (x + add)) },<span class="Apple-converted-space"> </span></p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>0.5, 7</p>
<p class="p13"><span class="Apple-tab-span">	</span>) * 0.2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p11"><b>Ex.4) The nOut arg</b></p>
<p class="p15"><br></p>
<p class="p15"><br></p>
<p class="p14">// nOut allows for switching between iteration levels up to maximum n</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span></span>|nOut = 10|</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(<span class="s5">LFDNoise1</span>.ar(20).range(3, 3.5) * x) }, [0.2, 0.3], 10, nOut) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p13">y.set(<span class="s9">\nOut</span>, 9)</p>
<p class="p4"><br></p>
<p class="p13">y.set(<span class="s9">\nOut</span>, 8)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p14">// it can be passed an array of levels,<span class="Apple-converted-space"> </span></p>
<p class="p14">// the resulting multichannel signal can e.g. be used for crossfaded switching with DXMix</p>
<p class="p4"><br></p>
<p class="p14">// switch between 3 mono signals and double them</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> src = <span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(<span class="s5">LFDNoise3</span>.ar(30).range(3, 4) * x) }, 0.2, 9, [5, 7, 9]) * 0.1;</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">DXMix</span>.ar(<span class="s5">Dseq</span>([0, 1, 2], <span class="s10">inf</span>), `src, fadeTime: 0.01, stepTime: 0.02, fadeMode: 1) ! 2</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release;</p>
<p class="p4"><br></p>
<p class="p14">// switch between 3 stereo signals</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s6">var</span> src = <span class="s5">GFIS</span>.ar({ <span class="s6">|x|</span> sin(<span class="s5">LFDNoise3</span>.ar(30).range(3, 4) * x) }, [0.2, 0.21], 9, [5, 7, 9]) * 0.1;</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">DXMix</span>.ar(<span class="s5">Dseq</span>([0, 1, 2], <span class="s10">inf</span>), `src, fadeTime: 0.01, stepTime: 0.02, fadeMode: 1)</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release;</p>
<p class="p4"><br></p>
<p class="p6"><span class="s7"><br>
</span><b>Ex.5) Comparison FIS / GFIS</b></p>
<p class="p14"><br>
// FIS is contained in the trnsnd quark</p>
<p class="p14">// first example of its helpfile</p>
<p class="p4"><br></p>
<p class="p13">{ <span class="s5">FIS</span>.ar(<span class="s5">LinExp</span>.ar(<span class="s5">LFTri</span>.ar(0.1), -1, 1, 1, 4), <span class="s5">LFNoise2</span>.ar(300).range(0, 1), 3, 0.1) }.play;</p>
<p class="p4"><br></p>
<p class="p14">// the same with GFIS requires definition of varying params outside func<span class="Apple-converted-space"> </span></p>
<p class="p13"><br>
(</p>
<p class="p13">y = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> r = <span class="s5">LinExp</span>.ar(<span class="s5">LFTri</span>.ar(0.1), -1, 1, 1, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> i = <span class="s5">LFNoise2</span>.ar(300).range(0, 1);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span> sin(r * x) }, i, 3, 3, <span class="s5">false</span>) * 0.1</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">y.release</p>
<p class="p4"><br></p>
<p class="p14">// proof of concept, difference is silent as it should</p>
<p class="p4"><br></p>
<p class="p13">(</p>
<p class="p13">z = {</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> r = <span class="s5">LinExp</span>.ar(<span class="s5">LFTri</span>.ar(0.1), -1, 1, 1, 4);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">var</span> i = <span class="s5">LFNoise2</span>.ar(300).range(0, 1);</p>
<p class="p13"><span class="Apple-tab-span">	</span><span class="s5">GFIS</span>.ar({ <span class="s5">|x|</span> sin(r * x) }, i, 3, 3, <span class="s5">false</span>) * 0.1 - <span class="s5">FIS</span>.ar(r, i, 3, 0.1)</p>
<p class="p13">}.play</p>
<p class="p13">)</p>
<p class="p4"><br></p>
<p class="p13">z.release</p>
<p class="p15"><br></p>
<p class="p15"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
</body>
</html>
