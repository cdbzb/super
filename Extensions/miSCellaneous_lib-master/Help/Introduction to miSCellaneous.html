<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1187.4">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
p.p4 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 28.0px; text-indent: -28.0px; font: 12.0px Helvetica}
p.p7 {margin: 0.0px 0.0px 0.0px 28.0px; text-indent: -28.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c00; min-height: 12.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #008322}
p.p14 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 11.0px Monaco; min-height: 15.0px}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #008300}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0326cb}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1c09}
p.p18 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0033c4}
p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #de0005}
p.p21 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 13.0px Helvetica}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {text-decoration: underline ; color: #01caff}
span.s5 {color: #0326cb}
span.s6 {color: #008300}
span.s7 {text-decoration: underline ; color: #0000ee}
span.s8 {color: #0033c4}
span.s9 {color: #434ccb}
span.s10 {text-decoration: underline ; color: #05cafb}
span.s11 {font: 12.0px Arial}
span.s12 {color: #008322}
span.s13 {color: #ff7222}
span.s14 {text-decoration: underline ; color: #04cafb}
span.s15 {text-decoration: underline ; color: #042eee}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>Introduction to miSCellaneous<span class="Apple-tab-span">	</span></b></span><b>overview, references and examples</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p1">At the beginning of 2017, it was almost 10 years ago when I did my first steps in systematically ordering and extending personal SC tools. At that time I already had some experience in SC, but project-oriented composition was my main focus. Meanwhile miSCellaneous lib has grown and when I look at its readme file, although I always tried to keep stuff documented properly, I doubt that the connections between the different classes would be easy to get at a first glance. Topics accumulated, some help files have become huge (VarGui, PbindFx) and a lot of examples and documented (extra-)features might hide the basic motivations. As I was asked by colleagues at the Institute of Electronic Music and Acoustic Graz (IEM) we organized a one-day lecture/workshop on miSCellaneous lib on November 5th, 2016, and this tutorial summarizes the overview given then. At that point I'd like to say that I'm very grateful to IEM Graz and the interested SC community from here and abroad for support and feedback, we are going to have further SC meetings at the same place – Hanns Holger Rutz already continued in December. There's also a focus on artistic research here at IEM, and research projects, events and discussions are lighting an ongoing discourse in the field between art and science, creating an inspiring environment.</p>
<p class="p1">Concerning the structure of this file: after a brief history and a grouping of content the tour will guide through selected topics in an order which, hopefully, will outline the central ideas. It will start with VarGui, PLx, then go over PbindFx, EventShortcuts to live coding aspects of PLx, continue with independent classes, class families, methods and SC tutorials and end with the Buffer Granulation tutorial, which again integrates some of the previous topics. PbindFx gets more space, as it's in my recent focus and you can use it for a number of things which are not, or at least not easily doable in plain SC. To a large extent the tour consists of references to selected already existing examples, which are spread over various help files. Conitinuative, but less central topics are marked as such, as well as some legacy code, which is still working, but not very relevant, as other possibilities have been invented meanwhile. A few new examples have been added, the reader is invited to check the exercises and to have fun with his/her favourite instrument resp. effect SynthDefs.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p4"><b>History</b></p>
<p class="p5"><br></p>
<p class="p1">In 2007 / 08 I was working at ZKM Karlsruhe, preparing a piece for flute and multichannel electronics (<i>Lokale Orbits / Solo 3</i>). Then I thought it would be useful to order and document my tools, by doing so my programming would – hopefully – not only be useful for me but for others too and I would be able to give something back to the open source community, from which I have been getting so much valuable input. Also I noticed that a better structuring of code together with the need of documentation stimulated reflection and development and significantly improved the functionality of my tools also just for personal use.<span class="Apple-converted-space"> </span></p>
<p class="p1"><i>Lokale Orbits </i>is a series of works for small instrumentations and multichannel tape where recordings with involved musicians were the base for granular processings. From the beginning miSCellaneous lib was developed in parallel to the needs that came from that artistic motivation. The first particular motivation was related to the fundamental architecture of SC – the division between language and server – and its consequences for granular synthesis. I never wanted to spend much time in gui programming, but I wanted to have a multi-purpose gui that would easily let me experiment with granular synthesis driven by language (patterns in particular) and server (granulation ugens). It should also be easy to combine these different controls in a single patch, e.g. fine-tune the parameters of a LFO and those of a Pattern resp. the derived running EventStreamPlayer at the same time. This need led to the development of the VarGui interface. It is the the oldest part and, so to speak, the kernel of miSCellaneous, already contained in the first public release of 2009. A player section and a number of features was added in 2011. Thus VarGui doesn't use SC's extended gui features which came up with Qt and if I had to build something from scratch I'd certainly look for a revised code structure, nevertheless VarGui reliably served my needs quite well over a long period of time. The twofold control option (environmental variables and synth args) turned out to be useful in many contexts, also the handling of arrays (environmental variables as well as synth args) is quite practical and allows a quick instantiation of huge slider+player guis.<span class="Apple-converted-space"> </span></p>
<p class="p1">Between 2009 and 2016 a number of pattern families was added, some of them with granular synthesis in mind. The one I'm using most is the PLx proxy pattern family which takes advantage of environmental variables and dynamic scoping and goes well together with the VarGui interface concerning control of running Patterns/EventStreamPlayers. PLx also opens nice opportunities for live-coding with very condensed syntax. I'm not doing this on stage but I see live-coding as valuable part of a dynamic compositional process. As a side remark, PLx patterns mirror most of SC's main lib patterns and can also be used as non-proxies. In contrast to main lib's list patterns they default to repeats = inf, which probably saved myself the typing of many thousands of 'infs' over the years.</p>
<p class="p1">Another part of miSCellaneous is a number of tutorials, which I added from time to time. Some refer to general SC topics, independent from miSCellaneous (e.g. Event patterns and array args), others to topics specific to miSCellaneous (e.g. PLx and live coding with Strings) and in some I tried a general overview of principal SC strategies, but also used examples with features of miSCellaneous (Buffer Granulation). Finally there's other stuff that doesn't fall into the above categories, e.g. the class EventShortcuts for customized shortcuts with Events and event patterns. Classes related to nonlinear dynamics (single sample feedback with Fb1, generalized functional iteration synthesis with GFIS) have been added in 2018, Fb1_ODE and related, a framework for general ordinary differential equation integration of initial value problems in 2019.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Groups of content</b></p>
<p class="p2"><br></p>
<p class="p1">.) <span class="Apple-tab-span">	</span>VarGui (2009), multi-purpose slider / player gui. Can have sliders for control of synth parameters and<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>environmental variables as well as a player section for control of Synths, Tasks or<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>EventStreamPlayers derived from Patterns.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6">.)<span class="Apple-tab-span">	</span>Pattern classes/class families:</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PHSx (2009): pattern-like objects using synth values in language,</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>still working but a bit outdated as we have synchronous buses now</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PLx (2012): dynamic scope proxy patterns,</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>especially suited for VarGui control, also live coding</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PSx (2014): patterns acting like streams and remembering last values,</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>good for certain types of nested pattern use and recursion</p>
<p class="p7"><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PmonoPar, PpolyPar (2015): differently timed setting of event streams</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PbindFx (2015): sequencing arbitrary effects and effect graphs</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>PLbindef, PLbindefPar (2016): proxies based on Pbindef</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>allowing shortcut replacement syntax</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>PSVx (2016): a pattern implementation of Xenakis sieves related to the class Sieve,</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Psieve patterns enable an unusual "realtime sieve modification".</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Interesting for many applications, e.g. granular rhythms,<span class="Apple-converted-space"> </span></p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>though I didn't have the time to experiment a lot yet.</p>
<p class="p7"><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>PSPdiv (2017): a dynamic multi-layer pulse divider based on Pspawner</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.) <span class="Apple-tab-span">	</span>Other pattern classes</p>
<p class="p7"><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6">.)<span class="Apple-tab-span">	</span>Tutorials:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Event patterns and Functions (2011)</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Event patterns and LFOs (2011)</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Buffer Granulation Tutorial (2012)</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>different strategies of buffer granulation and control</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Event patterns and array args (2015)</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>PLx and live coding with Strings (2016)</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Sieves and Psieve patterns (2016)</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>kitchen studies (2016)</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>commented source code of six short pieces from a kitchen sound using PbindFx</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Live Granulation Tutorial (2017)</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>different strategies of live granulation and control</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Other tutorials</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p6">.)<span class="Apple-tab-span">	</span>Other topics:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>enum (2013): general enumeration tool</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>EventShortcuts (2014): user-defined keywords for events and event patterns</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Smooth Clipping and Folding (2017)</p>
<p class="p2"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>DX suite (2017): pseudo ugens for crossfaded mixing and fanning with drate control</p>
<p class="p2"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Idev suite (2018): patterns and drate ugen searching for numbers with integer distance from a source pattern / signal</p>
<p class="p2"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Fb1, GFIS (2018): single sample feedback and generalized functional iteration synthesis</p>
<p class="p2"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Fb1_ODE (2019): general ordinary differential equation integration</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>ZeroXBufWr / ZeroXBufRd / TZeroXBufRd (2020): playing sequences of segments between zero crossings with demand rate control</p>
<p class="p7"><br></p>
<p class="p6"><span class="Apple-tab-span">	</span>.)<span class="Apple-tab-span">	</span>Other</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 1 – VarGui</b></p>
<p class="p8"><br></p>
<p class="p1">The <a href="VarGui.html"><span class="s4">VarGui</span></a> class help file as well <a href="VarGui shortcut builds.html"><span class="s4">VarGui shortcut builds</span></a> are both bloated with information, so I'd like to give just a few examples and references here in order to show its basic features.</p>
<p class="p2"><br></p>
<p class="p5"><br></p>
<p class="p9">(</p>
<p class="p9">s = <span class="s5">Server</span>.local;</p>
<p class="p9"><span class="s5">Server</span>.default = s;</p>
<p class="p9">s.boot;</p>
<p class="p9">)</p>
<p class="p10"><br></p>
<p class="p4"><b>Tour 1a: synth control</b></p>
<p class="p8"><br></p>
<p class="p11">// quick control of default synth, specs are globally known</p>
<p class="p11">// note that amp is set to 0 by its default spec</p>
<p class="p11">// start by pressing the green button</p>
<p class="p5"><br></p>
<p class="p9"><span class="s5">VarGui</span>(synth: <span class="s6">\default</span>).gui</p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p11">// alternative writing, see help file <a href="VarGui shortcut builds.html"><span class="s4">VarGui shortcut builds</span></a><span class="Apple-converted-space"> </span></p>
<p class="p5"><br></p>
<p class="p9"><span class="s6">\default</span>.sVarGui.gui<span class="Apple-converted-space">     </span></p>
<p class="p5"><br></p>
<p class="p2"><br></p>
<p class="p1">For basic control of a self-defined Synth/SynthDef by passing control specs see the example "synth definition with raising frequency" in <a href="VarGui.html"><span class="s4">VarGui</span></a>.</p>
<p class="p2"><br></p>
<p class="p1">For control of multiple Synths/SynthDefs see the example in the section "discussion" of the same file below.</p>
<p class="p2"><br></p>
<p class="p1">It's often more practical to pass control specs as SynthDef metadata as done in Ex. 1a of <a href="Buffer Granulation.html"><span class="s4">Buffer Granulation</span></a><span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Control your own (sustained) SynthDef with VarGui, either use SynthDef metadata or VarGui's argument 'synthCtr' for passing specs.<span class="Apple-converted-space"> </span></p>
<p class="p5"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 1b: environmental variables and pattern control</b></p>
<p class="p12"><br></p>
<p class="p1">For basic control of an environmental variable in combination with a Pbind run the example in the discussion section of <a href="VarGui.html"><span class="s4">VarGui</span></a>'s method 'new'.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p11">// after having evaluated p, consider the subtle differences of these variants:</p>
<p class="p11">// play with slider values and start and pause ad libitum.</p>
<p class="p11">// The quant argument ensures synchronization when starting players separately.</p>
<p class="p2"><br></p>
<p class="p11">// one array variable in one environment, one player</p>
<p class="p9">v = <span class="s5">VarGui</span>([<span class="s6">\midi</span>, [50, 70, <span class="s6">\lin</span>, 1, 55] ! 3], stream: p, quant: 0.2).gui;</p>
<p class="p5"><br></p>
<p class="p11">// three single variables in three environments, three players</p>
<p class="p9">v = <span class="s5">VarGui</span>([<span class="s6">\midi</span>, [50, 70, <span class="s6">\lin</span>, 1, 55]] ! 3, stream: p!3, quant: 0.2).gui;</p>
<p class="p5"><br></p>
<p class="p11">// three array variables in three environments, three players</p>
<p class="p9">v = <span class="s5">VarGui</span>([<span class="s6">\midi</span>, [50, 70, <span class="s6">\lin</span>, 1, 55] ! 3] ! 3, stream: p!3, quant: 0.2).gui;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">These examples show the application of dynamic scoping. A Function has been defined with an "unconnected" free variable and the players evaluate the Function in different Environments provided by the VarGui. Setting the sliders affects the variable of the same name in different Environments of different players.</p>
<p class="p2"><br></p>
<p class="p1">This example used a Pfunc, but it works the same with PLx patterns, we take a look at them and leave VarGui for a moment.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 2: PLx suite</b></p>
<p class="p2"><br></p>
<p class="p1">Pdef and Pdefn are main lib's proxies for replacement of event patterns and non-event patterns. PL is the most general PLx proxy, taking over some combined functionality of Pdef and Pdefn on the base of dynamic scoping, go through the examples of the help file <a href="PL.html"><span class="s4">PL</span></a> to see how it works with value and event patterns.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Though what neither PL nor Pdef/Pdefn can provide is the replacement of pure lists or list items in the case of list patterns. There's a main lib workaround with a combination of Pn and Plazy (<a href="PLx suite.html"><span class="s4">PLx suite</span></a>, Ex. 1a), but it isn't satisfying for several reasons, so I suppose that PLx list patterns like PLseq are amongst the most useful ones of the whole PLx family, e.g. see <a href="PLx suite.html"><span class="s4">PLx suite</span></a>, Ex. 1b. Other PLx list patterns like PLrand, PLwrand, PLser, PLshuf, PLshufn, PLswitch etc. work similar.</p>
<p class="p2"><br></p>
<p class="p1">There exists also a number of non-list PLx patterns, have a look at <a href="PLwhite.html"><span class="s4">PLwhite</span></a> as a typical example.</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Play your own enveloped SynthDef (or take default SynthDef with params: freq, amp, pan) with some PLx patterns and perform live replacements as in the examples above.</p>
<p class="p2"><br></p>
<p class="p5"><br></p>
<p class="p4"><b>Tour 3: PLx patterns used with VarGui</b></p>
<p class="p8"><br></p>
<p class="p1">See <a href="VarGui.html"><span class="s4">VarGui</span></a>, Ex. 1a, for basic step sequencing with PLseq, the array variable is implicitely defined in VarGui's first arg.</p>
<p class="p2"><br></p>
<p class="p1">See <a href="VarGui.html"><span class="s4">VarGui</span></a>, Ex. 1c for multiple players and array variables and control of multiple sliders and buttons with modifier keys (note that not all functionality might be available on all platforms).</p>
<p class="p10"><br></p>
<p class="p1">See <a href="VarGui.html"><span class="s4">VarGui</span></a>, Ex. 4a, for a sequencing setup with some PLs used. But more interesting here is that each synth reads is base frequency from a control bus, which gets its data from a separate synth. Synth and EventStreamPlayer are both controlled from the gui. The two slider blocks on the left side concern Synth settings (above) and variable setting for the Pbind / EventStreamPlayer (below). Accordingly we have two players on the right side. Try running the player and starting and stopping the control synth.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="s7"><a href="Buffer Granulation.html">Buffer Granulation</a></span>, Ex. 2a, shows basic language-driven granulation, gui values are taken over by PL patterns and Pfunc.</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Write a combination of an event pattern and PLx patterns as above with your own SynthDef and play it with a VarGui. Note that it's not necessary to control all args by the gui, nor is it necessary to control parameters directly: you can e.g. control bounds for midinotes in the gui and define the calculation for the actual midinote (e.g. random selection) in the event pattern:</p>
<p class="p2"><br></p>
<p class="p13">\midinote<span class="s2">, </span><span class="s8">PLwhite</span><span class="s2">(</span>\midiLo<span class="s2">, </span>\midiHi<span class="s2">)</span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 4: PbindFx</b></p>
<p class="p8"><br></p>
<p class="p1">PbindFx is an event pattern for effect handling on per-event base. There are other ways for working with event patterns and effects, already possible with main lib, but they have disadvantages: with Pfx and Pfxb there is no built-in way to sequence effect types or effect parameters, you could also route the event's audio to effect buses, but for overlapping events with different fx graphs/params you'd have to define additional buses beforehand as in Ex. 4a.</p>
<p class="p2"><br></p>
<p class="p10"><br></p>
<p class="p4"><b>Ex. 4a: sequencing fx params by using different fx buses</b></p>
<p class="p8"><br></p>
<p class="p11">// first go to <a href="PbindFx.html"><span class="s7">PbindFx</span></a>, Ex. 1a, reboot server with extended ressources and evaluate source and fx synths.</p>
<p class="p14"><br></p>
<p class="p11">// start fxs<span class="Apple-converted-space"> </span></p>
<p class="p9">(</p>
<p class="p9">a = <span class="s5">Bus</span>.audio(s, 2);</p>
<p class="p9">b = <span class="s5">Bus</span>.audio(s, 2);</p>
<p class="p5"><br></p>
<p class="p9">x = <span class="s5">Synth</span>(<span class="s6">\echo</span>, [decayTime: 1.5, echoDelta: 0.15, in: a]);</p>
<p class="p9">y = <span class="s5">Synth</span>(<span class="s6">\echo</span>, [decayTime: 5, echoDelta: 0.1, in: b]);</p>
<p class="p9">)</p>
<p class="p5"><br></p>
<p class="p11">// play pattern, the two effects allow switching between them</p>
<p class="p9">(</p>
<p class="p9">p = <span class="s5">Pbind</span>(</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.5,</p>
<p class="p15"><span class="s2"><span class="Apple-tab-span">	</span></span>\instrument<span class="s2">, </span>\source<span class="s2">,</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\note</span>, <span class="s5">Pshuf</span>((0..11), <span class="s9">inf</span>) + <span class="s5">Pseq</span>([[0.2, 14.2], [0, 4], [0, 4]], <span class="s9">inf</span>),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\octave</span>, <span class="s5">Pwhite</span>(3, 6),</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span></span><span class="s6">\out</span><span class="s2">, </span><span class="s5">Pseq</span><span class="s2">([b, a, a], </span><span class="s9">inf</span><span class="s2">)<span class="Apple-converted-space">  </span></span>// here we do fx sequencing</p>
<p class="p9">).play</p>
<p class="p9">)</p>
<p class="p5"><br></p>
<p class="p9">p.stop</p>
<p class="p8"><br></p>
<p class="p11">// we need to do cleanup manually here</p>
<p class="p5"><br></p>
<p class="p9">[x, y, a, b].do(<span class="s5">_</span>.free);</p>
<p class="p10"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 4b: sequencing fx params by using PbindFx</b></p>
<p class="p8"><br></p>
<p class="p11">// Ex. 4a translated to PbindFx syntax –</p>
<p class="p11">// though it's not exactly identical as fxs are processed in not only two but</p>
<p class="p11">// more parallel fx synths</p>
<p class="p5"><br></p>
<p class="p9">(</p>
<p class="p16"><span class="s2">p = </span>PbindFx<span class="s2">([</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.5,</p>
<p class="p15"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\instrument<span class="s2">, </span>\source<span class="s2">,</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\note</span>, <span class="s5">PLshuf</span>((0..11)) + <span class="s5">PLseq</span>([[0.2, 14.2], [0, 4], [0, 4]]),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\octave</span>, <span class="s5">Pwhite</span>(3, 6),</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">\fxOrder</span><span class="s2">, 1<span class="Apple-tab-span">	</span></span>// always fx #1 (echo)</p>
<p class="p9"><span class="Apple-tab-span">	</span>],[</p>
<p class="p15"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\fx<span class="s2">, </span>\echo<span class="s2">,</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\decayTime</span>, <span class="s5">PLseq</span>([5, 1.5, 1.5]),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\echoDelta</span>, <span class="s5">PLseq</span>([0.1, 0.15, 0.15]),</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s6">\cleanupDelay</span><span class="s2">, 5.2,<span class="Apple-converted-space">    </span></span>// with short default echo would be cut</p>
<p class="p5"><br></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// this would save a bit CPU</p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// \cleanupDelay, PLseq([5, 1.5, 1.5]) + 0.2</p>
<p class="p9"><span class="Apple-tab-span">	</span>]</p>
<p class="p9">).play</p>
<p class="p9">)</p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p11">// cleanup (delayed freeing of synths and buses) is done automatically</p>
<p class="p11">// watch server window:</p>
<p class="p5"><br></p>
<p class="p9">p.stop</p>
<p class="p10"><br></p>
<p class="p10"><br></p>
<p class="p11">// now run the same example with the following variant of 'echoDelta',</p>
<p class="p11">// obviously the result cannot be achieved with an approach like in Ex. 4a</p>
<p class="p5"><br></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\echoDelta</span>, <span class="s5">Pwhite</span>(0.05, 0.2)</p>
<p class="p5"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Ex. 4c: alternation of fx / non-fx by defining a fxOrder sequence</b></p>
<p class="p5"><br></p>
<p class="p9">(</p>
<p class="p16"><span class="s2">p = </span>PbindFx<span class="s2">([</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.2,</p>
<p class="p15"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\instrument<span class="s2">, </span>\source<span class="s2">,</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\note</span>, <span class="s5">PLshuf</span>((0..11)) + <span class="s5">PLseq</span>([[0.4, 14.4], [0, 4], [0, 4]]),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\octave</span>, <span class="s5">Pwhite</span>(3, 6),</p>
<p class="p5"><br></p>
<p class="p17"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// fxOrder = 0 means no fx</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>,<span class="Apple-converted-space">  </span><span class="s5">PLseq</span>([0, 0, 1]),</p>
<p class="p5"><br></p>
<p class="p11"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// if no fx, we need to compensate the unified echo delay of 0.2</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\lag</span>, <span class="s5">Pif</span>(<span class="s5">Pkey</span>(<span class="s6">\fxOrder</span>) &gt; 0, 0, 0.2)</p>
<p class="p9"><span class="Apple-tab-span">	</span>],[</p>
<p class="p15"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>\fx<span class="s2">, </span>\echo<span class="s2">,</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\decayTime</span>, <span class="s5">PLseq</span>([5, 1.5, 1.5]),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\echoDelta</span>, <span class="s5">Pwhite</span>(0.04, 0.12),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s6">\cleanupDelay</span>, <span class="s5">PLseq</span>([5, 1.5, 1.5]) + 0.2</p>
<p class="p9"><span class="Apple-tab-span">	</span>]</p>
<p class="p9">).play</p>
<p class="p9">)</p>
<p class="p5"><br></p>
<p class="p9">p.stop</p>
<p class="p10"><br></p>
<p class="p8"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of no fx and echos (by defining 'fxOrder') and echo params as in Ex. 4c. Note that in fx 'echo' the max echoDelta defaults to 0.2.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4d: principle of operation</b></p>
<p class="p8"><br></p>
<p class="p1">For each event several issues have to be internally considered by PbindFx: building and checking of fx graphs (no cycles !), cleaning buses from possibly remaining residual audio (adding "zero synths"), splitting (in case of parallel parts in the fx graph), grouping of all event-related synths and checking accumulated cleanup delay times. You might skip that for the moment, but for a more detailled overview see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, as well as for a listing of conventions.</p>
<p class="p18"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4e: sequential application of fxs (fixed fx chains)</b></p>
<p class="p8"><br></p>
<p class="p1">See <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, examples 1a and 1b.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4f: sequencing different fx chains</b></p>
<p class="p8"><br></p>
<p class="p1">See <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, examples 2a-d.</p>
<p class="p8"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of fx chains (your fxs and/or fxs from PbindFx help). Maybe just extend your last own example.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4g: parallel effects and arbitrary effect graphs</b></p>
<p class="p8"><br></p>
<p class="p1">It seems to be a still underestimated option to design effect graphs different from simple chains. In a classical DAW interface a pile of slots for effects in chain is common, although more differentiated possibilities are also there. Considering event sequencing with PbindFx we can select fx graphs per event / grain, in addition to the sequencing of fx parameters itself. See <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 10a for a parallel application of echo, note the syntax of the event graph, passed as Event to 'fxOrder'.</p>
<p class="p2"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Compare the sound of the two fx graphs given in Ex. 10a, also try the following or similar, how do the corresponding fx graphs look like ?</p>
<p class="p5"><br></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>, `(0: 1, 1: [2, 3], 2: 4),</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>, `(0: 1, 1: [2, 3, <span class="s6">\o</span>], 2: 4),</p>
<p class="p5"><br></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>, `(0: 1, 1: [2, 3], 3: 4, 2: 3),</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>, `(0: 1, 1: [2, 3], 3: 2, 2: 4),</p>
<p class="p5"><br></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s6">\fxOrder</span>, `(0: 1, 1: [2, 3, <span class="s6">\o</span>], 3: 4, 2: 3),</p>
<p class="p5"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">See <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 10b and 10c for modulation graphs and their sequencing.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Play your own (percussive + stereo) SynthDef (or instrument 'source') with an arbitrary sequencing of fx *graphs* (your fxs and/or fxs from PbindFx help). Maybe just extend your last own example.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4h: implicit parallelism of single effects</b></p>
<p class="p8"><br></p>
<p class="p1">This can simple be done by passing arrays within fxData, see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 4a.<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4i: different effects with parallel PbindFxs</b></p>
<p class="p8"><br></p>
<p class="p1">A further option for parallelism, a typical case would be the application of different effects to the notes of a chord, see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 3b (rather straight than 3a).<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4j: PbindFx and replacements</b></p>
<p class="p8"><br></p>
<p class="p1">See <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 7a for replacement of key streams.</p>
<p class="p10"><br></p>
<p class="p1">Up to now PbindFx got lists as args in all examples. As args can be event patterns too, they can also be proxy patterns which opens the door for various unusual kinds of source and fx replacements, see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 7b and 7c.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Take one of your previous working PbindFx examples and rewrite its args (arrays of key/value pairs) as PL or Pbindef proxies. Run the example and replace source and/or fx patterns on the fly.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 4k: continuative topics</b></p>
<p class="p8"><br></p>
<p class="p1">For use with VarGui see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 8.</p>
<p class="p8"><br></p>
<p class="p1">For using one fx SynthDef in more than one fxData see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 4.</p>
<p class="p8"><br></p>
<p class="p1">For source and fxs reading from external buses (ar or kr) see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 6a-c.</p>
<p class="p8"><br></p>
<p class="p1">For using value conversions with fxData see <a href="PbindFx.html"><span class="s4">PbindFx</span></a>, Ex. 9.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 4l: kitchen studies, a granular synthesis application</b></p>
<p class="p2"><br></p>
<p class="p1">One motivation for the development of PbindFx was the idea to explore granular synthesis variants with differentiated effect processings. The fixed media composition <i>kitchen studies</i> collects six short pieces with different fxs and handlings of fx sequencing, each derived from the kitchen sound of five seconds, which is already contained in miSCellaneous lib. At the same time <i>kitchen studies</i> is an ongoing artistic research project: the commented source code is published in the tutorial <a href="kitchen studies.html"><span class="s10">kitchen studies</span></a>, <span class="s11">compressed versions of the original piece as a whole and its parts can be found on my website <a href="http://daniel-mayer.at/index_en.htm"><span class="s10">http://daniel-mayer.at</span></a>, a further documentation of the compositional process will follow as publication in the artistic research database <i>Research Catalogue</i> (<a href="http://researchcatalogue.net/"><span class="s10">http://researchcatalogue.net</span></a>).</span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 5: EventShortcuts: less typing with Events and event patterns</b></p>
<p class="p8"><br></p>
<p class="p1">EventShortcuts is an interface for defining your own shortcut keys for often used keyword in Events and event patterns. For example you might want to write 'inst' or just 'i' instead of 'instrument' etc., then define your collection of shortcuts – e.g. in your startup or a certain load file – and activate it on occasion. There is also a default shortcuts dictionary, see its content and play a simple example:</p>
<p class="p2"><br></p>
<p class="p5"><br></p>
<p class="p19">EventShortcuts<span class="s2">.on;</span></p>
<p class="p5"><br></p>
<p class="p19">EventShortcuts<span class="s2">.postAll;</span></p>
<p class="p5"><br></p>
<p class="p9">x = <span class="s8">Pbind</span>(<span class="s12">\m</span>, <span class="s8">Pwhite</span>(60, 90), <span class="s12">\d</span>, 0.2).play;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">For examples of (re-)defining or extending shortcut dictionaries see <a href="EventShortcuts.html"><span class="s10">EventShortcuts</span></a>.</p>
<p class="p8"><br></p>
<p class="p1"><span class="s3">Exercise</span><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p1">Take one of your favourite SynthDefs with non-standard arguments (other than freq, amp, pan, etc.) and write an event pattern example, using these arguments. Then choose useful abbreviations, define a new shortcut dictionary with these (either by extending the default or by defining a new one), make it current and run the event pattern example with abbreviated keys.<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 6: live coding</b></p>
<p class="p8"><br></p>
<p class="p1">This was not my main focus from the beginning, but it turned out that PLx patterns, in combination with EventShortcuts and/or Character sequencing (tour 6b) open up live coding possibilities with very condensed syntax.</p>
<p class="p2"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 6a: PLbindef and PLbindefPar</b></p>
<p class="p2"><br></p>
<p class="p1">PLbindef is a wrapper class for Pbindef, which allows replacements in pseudo-method syntax in a newly created Environment.</p>
<p class="p2"><br></p>
<p class="p19">EventShortcuts<span class="s2">.on;</span></p>
<p class="p5"><br></p>
<p class="p9">y = <span class="s8">PLbindef</span>(<span class="s12">\x</span>, <span class="s12">\d</span>, 0.2, <span class="s12">\m</span>, <span class="s8">Pwhite</span>(60, 90)).play;</p>
<p class="p5"><br></p>
<p class="p20">// now 'x' is also the name of a new Environment in the current Environment,</p>
<p class="p20">// its pseudo-methods can be used for setting</p>
<p class="p5"><br></p>
<p class="p9"><span class="s13">~x</span>.m = <span class="s8">PLseq</span>((60..70))</p>
<p class="p5"><br></p>
<p class="p9">y.stop</p>
<p class="p8"><br></p>
<p class="p1">For further examples see <a href="PLbindef.html"><span class="s10">PLbindef</span></a>.</p>
<p class="p2"><br></p>
<p class="p1">PLbindefPar is also based on Pbindef, but unlike PLbindef it's not a plain wrapper: it employs a number of Pbindefs in parallel, which allows control of polyphonic, additive or granular structures, see <a href="PLbindefPar.html"><span class="s10">PLbindefPar</span></a>. <b>WARNING: </b>if you're piling up a lot of layers, be careful with amplitudes, the amplitude values are taken for the single layers, so you'd have to reduce them accordingly !</p>
<p class="p2"><span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 6b: PLx and live coding with Strings</b></p>
<p class="p2"><br></p>
<p class="p1">Already in plain SC Strings as Arrays of Characters can be used for sequencing. PLx patterns fit and continuate this concept, see <a href="PLx and live coding with Strings.html"><span class="s10">PLx and live coding with Strings</span></a> for some options, also in connection with PLbindef, PLbindefPar and PbindFx.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 7: independent classes, class families and methods</b></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 7a: PSx stream patterns</b></p>
<p class="p8"><br></p>
<p class="p1">These are a bit paradoxical classes: Patterns which behave as if they were Streams, thus have an internal state and remember its last value(s), which can e.g. be used for recursion or certain demands of repeated embedding as in the following example:</p>
<p class="p2"><br></p>
<p class="p9">(</p>
<p class="p11">// PS gets source and length patterns as args</p>
<p class="p5"><br></p>
<p class="p9">p = <span class="s5">PLseq</span>([</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s5">PS</span>(<span class="s5">PLseq</span>((1..5)), <span class="s5">PLseq</span>([1, 2])),</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s5">PS</span>(<span class="s5">PLseq</span>((1..5) * 100), <span class="s5">PLrand</span>((3..5)))</p>
<p class="p9">]);</p>
<p class="p5"><br></p>
<p class="p9">p.asStream.nextN(100)</p>
<p class="p9">)</p>
<p class="p2"><br></p>
<p class="p11">// this can also be written with a combination of Streams and Patterns,</p>
<p class="p11">// but it needs more typing (same with Pswitch1 variants)</p>
<p class="p5"><br></p>
<p class="p9">(</p>
<p class="p9">a = <span class="s5">Pseq</span>((1..5), <span class="s9">inf</span>).asStream;</p>
<p class="p9">b = <span class="s5">Pseq</span>((1..5) * 100, <span class="s9">inf</span>).asStream;</p>
<p class="p5"><br></p>
<p class="p9">p = <span class="s5">Pseq</span>([</p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s5">Pfuncn</span>({ a.next }, <span class="s5">Pseq</span>([1, 2], <span class="s9">inf</span>).asStream),<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="Apple-tab-span">	</span><span class="s5">Pfuncn</span>({ b.next }, <span class="s5">Prand</span>((3..5), <span class="s9">inf</span>).asStream),</p>
<p class="p9">], <span class="s9">inf</span>);</p>
<p class="p5"><br></p>
<p class="p9">p.asStream.nextN(100)</p>
<p class="p9">)</p>
<p class="p2"><br></p>
<p class="p1">See <a href="PSx stream patterns.html"><span class="s7">PSx stream patterns</span></a> for an overview.</p>
<p class="p10"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 7b: PSVx sieve patterns and Sieves</b></p>
<p class="p8"><br></p>
<p class="p1">Sieves, recommended by Iannis Xenakis as generative principles for arbitrary musical parameters, are implemented twice: with the class Sieve and Psieve patterns, which adapt the sieve calculus for realtime interactions. The tutorial <a href="Sieves and Psieve patterns.html"><span class="s14">Sieves and Psieve patterns</span></a> starts from scratch, thus can be studied completely independent from other miSCellaneous stuff and most other SC requirements. The last chapter gives some audio examples, granular rhythms might be an especially interesting application.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 7c: PmonoPar and PpolyPar</b></p>
<p class="p8"><br></p>
<p class="p1"><span class="s7"><a href="PmonoPar.html">PmonoPar</a></span> follows the Pmono convention of a single synth, being set but extends it to an arbitrary number of differently timed setting streams. With <a href="PpolyPar.html"><span class="s14">PpolyPar</span></a> the number of continously running synths is arbitrary as well and setting streams can switch the synths to set. That way complicated fx variations can be achieved by a paradigm different from <a href="PbindFx.html"><span class="s4">PbindFx</span></a>.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 7d: enum</b></p>
<p class="p8"><br></p>
<p class="p1">A general tool, which can be used for many enumeration and optimization problems (sets, partitions, graphs etc.), melodic shapes and scales are possible musical applications, see <a href="enum.html"><span class="s4">enum</span></a>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 7e: HS / HSpar / PHS / PHSpar</b></p>
<p class="p8"><br></p>
<p class="p1">A framework for using server-generated values in Pbind-like objects in the language. A bit outdated now, as synchronous bus gives easy access to server values, however the double-latency mechanism provides a good accuracy of values – better than synchronous bus with standard hardware settings if this is needed – by passing a high granularity parameter. A lower value minimizes OSC traffic if this is more important. See <a href="Working with HS and HSpar.html"><span class="s4">Working with HS and HSpar</span></a>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 7f: PSPdiv</b></p>
<p class="p8"><br></p>
<p class="p1">A dynamic multi-layer pulse divider based on Pspawner, as the latter it supports parallel and sequential sprouting of sub-patterns. Might be used for line ornamentation, polyrhythmical structures, granulation etc., see <a href="PSPdiv.html"><span class="s14">PSPdiv</span></a>.</p>
<p class="p2"><br></p>
<p class="p18"><br></p>
<p class="p4"><b>Tour 7g: Smooth Clipping and Folding</b></p>
<p class="p8"><br></p>
<p class="p1">A suite of pseudo ugens, see <a href="Smooth Clipping and Folding.html"><span class="s14">Smooth Clipping and Folding</span></a>.</p>
<p class="p2"><br></p>
<p class="p18"><br></p>
<p class="p4"><b>Tour 7h: DX suite</b></p>
<p class="p8"><br></p>
<p class="p1">pseudo ugens for crossfaded mixing and fanning according to demand-rate control, see <a href="DX suite.html"><span class="s15">DX suite</span></a>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 7i: Idev suite</b></p>
<p class="p8"><br></p>
<p class="p6">patterns and drate ugen searching for numbers with integer distance from a source pattern / signal, see <a href="Idev suite.html"><span class="s15">Idev suite</span></a>.</p>
<p class="p2"><br></p>
<p class="p7"><br></p>
<p class="p4"><b>Tour 7j: Nonlinear dynamics</b></p>
<p class="p8"><br></p>
<p class="p1">pseudo ugens for single sample feedback and generalized functional iteration synthesis, see <a href="Fb1.html"><span class="s15">Fb1</span></a> and <a href="GFIS.html"><span class="s15">GFIS</span></a>.<span class="Apple-converted-space"> </span></p>
<p class="p1">General ordinary differential equation integration, see <a href="Fb1_ODE.html"><span class="s15">Fb1_ODE</span></a> and related classes.</p>
<p class="p2"><br></p>
<p class="p21"><b>Tour 7k: ZeroXBufWr / ZeroXBufRd / TZeroXBufRd</b></p>
<p class="p8"><br></p>
<p class="p1">pseudo ugens for zero crossing analysis and playing sequences of segments between them with demand rate control, see <a href="ZeroXBufWr.html"><span class="s15">ZeroXBufWr</span></a>, <a href="ZeroXBufRd.html"><span class="s15">ZeroXBufRd</span></a><span class="s15">,</span> <a href="TZeroXBufRd.html"><span class="s7">TZeroXBufRd</span></a><span class="s15">.</span></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p4"><b>Tour 8: (Rather) independent SC tutorials</b></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 8a: Event patterns and Functions</b></p>
<p class="p8"><br></p>
<p class="p1">This tutorial is about dynamic scope, comparing the behaviour of Functions, Streams and EventStreamPlayers in Environments. It's thus treating some preconditions which are relevant for <a href="PLx suite.html"><span class="s4">PLx suite</span></a><span class="s4"> </span>and <a href="VarGui.html"><span class="s4">VarGui</span></a>, see <a href="Event patterns and Functions.html"><span class="s4">Event patterns and Functions</span></a>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Tour 8b: Event patterns and LFOs</b></p>
<p class="p8"><br></p>
<p class="p1">Continuous (with LFO) and discrete ("LFO-like") control strategies for event patterns are compared in <a href="Event patterns and LFOs.html"><span class="s4">Event patterns and LFOs</span></a>.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 8c: Event patterns and array args</b></p>
<p class="p8"><br></p>
<p class="p1">SynthDef array args seem to be a sometimes confusing topic, especially when it's about (pseudo-)variable array lengths and Envelopes, this is even more the case when it comes to the sequencing of such synths. For this reason, and not at last to remind myself to the subtle syntax differences, I wrote this tutorial: <a href="Event patterns and array args.html"><span class="s4">Event patterns and array args</span></a>.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><b>Tour 9: Buffer Granulation and Live Granulation – tutorials</b></p>
<p class="p8"><br></p>
<p class="p1">Actually scheduled as a general overview of granulation possibilities in SC, also collecting various ideas from the sc-users mailing list discussions, I have to admit that in its current form many examples, especially in the Buffer granulation tutorial, require one or more features of miSCellaneous and thus might not always be easy to follow. Then again it would be hard to write such (gui) examples without presuppositions and at the same time with a clearly representable amount of code. However I hope that based on this guided tour it might be easier to step through for people who haven't used this lib before, see <a href="Buffer Granulation.html"><span class="s14">Buffer Granulation</span></a> and <a href="Live Granulation.html"><span class="s14">Live Granulation</span></a>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
