<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="949.54">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #000bf2}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica}
p.p8 {margin: 0.0px 0.0px 0.0px 85.0px; text-indent: -85.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ff0000; min-height: 12.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica}
p.p11 {margin: 0.0px 0.0px 0.0px 57.0px; text-indent: -57.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #e80000}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #e80000; min-height: 12.0px}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #e20000}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ff5400}
p.p18 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #001fff}
p.p19 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ca0000}
p.p20 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0011ff}
p.p21 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ca0000; min-height: 12.0px}
p.p22 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #e20000; min-height: 12.0px}
p.p23 {margin: 0.0px 0.0px 0.0px 0.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {text-decoration: underline}
span.s4 {color: #007300}
span.s5 {color: #0022ff}
span.s6 {color: #001fff}
span.s7 {color: #0039d2}
span.s8 {color: #0011ff}
span.s9 {color: #2835c5}
span.s10 {font: 12.0px Helvetica}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>enum<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>general enumeration tool, can be used for a variety of combinatorial problems</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Part of:</b> <a href="miSCellaneous.html"><span class="s3">miSCellaneous</span></a></span></p>
<p class="p2"><br></p>
<p class="p1">Method enum implements a basic backtracking search suited for a number of counting and</p>
<p class="p1">optimization problems. For specification of search criteria a boolean-valued Function<span class="Apple-converted-space"> </span></p>
<p class="p1">has to be passed.</p>
<p class="p2"><br></p>
<p class="p4"><b>Some Important Issues Regarding method enum</b></p>
<p class="p2"><br></p>
<p class="p1">The method applies to Integers indicating the recursion depth.</p>
<p class="p1">Due to the nature of combinatorial problems with an often rapid growth of solutions</p>
<p class="p1">and/or enumeration steps with increase of size, it is recommended to start<span class="Apple-converted-space"> </span></p>
<p class="p1">examples with low numbers to avoid hangs.</p>
<p class="p2"><br></p>
<p class="p5"><b><span class="Apple-tab-span">	</span>Integer::enum (pool, function, evalAtZero, type, order, maxNum)</b></p>
<p class="p6"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p5"><b><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b>Returns solutions of the problem, which is defined by <b>function</b>,</p>
<p class="p5"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>as an Array of SequenceableCollections (size = receiver).</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>pool </b>- SequenceableCollection of items to be considered for<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>possible solutions.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>If type equals 0 the same pool is taken for all indices of possible solutions,</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if type equals 1 a SequenceableCollection of pools might be passed.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>The existence of an additional <b>type</b> arg is necessary as it might also be desirable</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>to consider SequenceableCollections as single items of possible solutions.</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>function </b>- Boolean-valued Function to be evaluated at <b>currentIndex</b>.<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>For many applications it is not necessary to evaluate at index 0</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(so per default <b>evalAtZero </b>set to false), the Function is not evaluated</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>and the item is supposed to be considered as first element of a possible solution.</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>From current state the Function is passed the following args to specify search:</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>item </b>- Current item to be checked</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>currentIndex </b>- Current enumeration level,<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>between 1 (resp. 0 in case <b>evalAtZero </b>set to true) and receiver - 1</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>currentCol </b>- Contains current collection of items already chosen</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>at indices up to <b>currentIndex </b>- 1, for efficiency reasons<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>length of this collection equals receiver and items indexed at<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>current or higher enumeration level might stem from earlier enumeration steps.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>indexCol </b>- Current collection of indices (of items from <b>pool</b>) already chosen,<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for efficiency reasons length of this collection equals receiver and indices at<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>current or higher enumeration level might stem from earlier enumeration steps.</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>evalAtZero </b>- Boolean. Determines if <b>function </b>will be evaluated at index 0.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to false.</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>type </b>- Must be 0 or 1. Determines if <b>pool</b> should be taken for all items (0, default)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>or specified per index (1).</p>
<p class="p8"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>order </b>- Boolean. Determines if search should follow order of items given in <b>pool</b></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>or a search order is randomly chosen. Defaults to true.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>For search of a single random solution one would set <b>order</b> to false and</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>maxNum</b> to 1.</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>maxNum </b>- Integer. Maximum number of solutions to be searched for.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>Defaults to inf.</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p10"><b>Example 1: <span class="Apple-converted-space">  </span>Basic enumerations, Subsets</b></p>
<p class="p11"><br></p>
<p class="p12"><br></p>
<p class="p13">// Listing all tuples from a given collection.</p>
<p class="p13">// Note that this kind of complete enumeration<span class="Apple-converted-space"> </span></p>
<p class="p13">// can be done with method allTuples more efficiently.</p>
<p class="p14"><br></p>
<p class="p12"><br></p>
<p class="p15">3.enum([1,2])</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 2, 1 ], [ 1, 2, 2 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 2, 1, 1 ], [ 2, 1, 2 ], [ 2, 2, 1 ], [ 2, 2, 2 ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p13">// type 1 for specified pool(s)<span class="Apple-converted-space"> </span></p>
<p class="p13">// receiver must equal size of passed pools</p>
<p class="p12"><br></p>
<p class="p15">3.enum([[1,2], [-1,-2], [<span class="s4">\a</span>,<span class="s4">\b</span>]], type: 1)</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, -1, a ], [ 1, -1, b ], [ 1, -2, a ], [ 1, -2, b ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 2, -1, a ], [ 2, -1, b ], [ 2, -2, a ], [ 2, -2, b ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p13">// strictly monotone tuples<span class="Apple-converted-space"> </span></p>
<p class="p13">// note that function is evaluated only for i &gt; 0,</p>
<p class="p13">// so no problem to write i-1<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">3.enum((1..4), { <span class="s5">|x,i,col|</span> x &gt; col[i-1] });<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p13">// Above is equivalent to the task of finding all</p>
<p class="p13">// k-subsets of a given set of n elements.</p>
<p class="p13">// The results are lexically ordered.</p>
<p class="p13">// For an arbitrary pool, not necessarily numbers,</p>
<p class="p13">// you can use the index collection arg within the Function.</p>
<p class="p12"><br></p>
<p class="p15">3.enum([<span class="s4">\a</span>, <span class="s4">\b</span>, <span class="s4">\c</span>, <span class="s4">\d</span>], { <span class="s5">|x,i,col,icol|</span> icol[i] &gt; icol[i-1] });<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ a, b, c ], [ a, b, d ], [ a, c, d ], [ b, c, d ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p16">// The number of k-subsets of a set of length n equals<span class="Apple-converted-space">  </span>n! / k! / (n-k)!</p>
<p class="p16">// You might want to check before a complete enumeration:</p>
<p class="p12"><br></p>
<p class="p17">~subsetNum<span class="s2"> = { </span><span class="s6">|n, k|</span><span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p15">    <span class="s6">var</span> p = 1;<span class="Apple-converted-space"> </span></p>
<p class="p15">    k.do { <span class="s6">|i|</span> p = p * (n - k + i + 1) / (i + 1) };<span class="Apple-converted-space"> </span></p>
<p class="p15">    p<span class="Apple-converted-space"> </span></p>
<p class="p15">};<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p17">~subsetNum<span class="s2">.(18,5)</span></p>
<p class="p12"><br></p>
<p class="p15">-&gt; 8568</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p16">// In principle search for tuples with certain features (not only subsets)</p>
<p class="p16">// can always be done with using allTuples<span class="s2"> </span>and filtering out afterwards,<span class="Apple-converted-space"> </span></p>
<p class="p16">// but this is only feasible<span class="s2"> </span>for small n.</p>
<p class="p16">// E.g. n = 18 and k = 5 requires calculating<span class="s2"> </span>1889568 (n**k) tuples first.<span class="Apple-converted-space"> </span></p>
<p class="p16">// Furthermore method allTuples defaults to<span class="s2"> </span>a maximum number of 16364 (2**14).</p>
<p class="p16">// So (18**5).log2.ceil (21) gives the exponent of 2 to pass<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">{<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>((1..18)!5).allTuples((2**21).asInteger)</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>.select { <span class="s6">|y|</span> y.every { <span class="s6">|x,i|</span> (i == 0) or: { y[i-1] &lt; y[i] } } }.size.postln;<span class="Apple-converted-space"> </span></p>
<p class="p15">}.bench</p>
<p class="p12"><br></p>
<p class="p15">-&gt; 8568</p>
<p class="p15">time to run: 6.6191733989999 seconds.</p>
<p class="p15">6.6191733989999</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p15">{ 5.enum((1..18), { <span class="s5">|x,i,col|</span> x &gt; col[i-1] }).size.postln; }.bench</p>
<p class="p12"><br></p>
<p class="p15">-&gt; 8568</p>
<p class="p15">time to run: 0.10966498400012 seconds.</p>
<p class="p15">0.10966498400012</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p16">// Tuples without repetitions -</p>
<p class="p16">// keep in mind that passed collection is of full length in each step,<span class="Apple-converted-space"> </span></p>
<p class="p16">// so we have to restrict to the indices up to i-1.</p>
<p class="p16">// Writing col[(0..i-1)] means that a new Array is generated in</p>
<p class="p16">// every enumeration step. This might be a bottleneck</p>
<p class="p16">// with a huge number of steps and could be optimized.<span class="s2"> </span><span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">3.enum((1..4), { <span class="s6">|x,i,col|</span> col[(0..i-1)].includes(x).not });<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">-&gt; [[ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 2 ], [ 1, 3, 4 ], [ 1, 4, 2 ], [ 1, 4, 3 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 2, 1, 3 ], [ 2, 1, 4 ], [ 2, 3, 1 ], [ 2, 3, 4 ], [ 2, 4, 1 ], [ 2, 4, 3 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 3, 1, 2 ], [ 3, 1, 4 ], [ 3, 2, 1 ], [ 3, 2, 4 ], [ 3, 4, 1 ], [ 3, 4, 2 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 4, 1, 2 ], [ 4, 1, 3 ], [ 4, 2, 1 ], [ 4, 2, 3 ], [ 4, 3, 1 ], [ 4, 3, 2 ]]</p>
<p class="p12"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p10"><b>Example 2: <span class="Apple-converted-space">  </span>Melodic Shapes</b></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p13">// This follows an idea by Fabrice Mogini</p>
<p class="p13">// Given a sequence of pitches, find all melodies of same shape,</p>
<p class="p13">// here just understood as up-and-down movement,</p>
<p class="p13">// using the given pitches without repetition.</p>
<p class="p14"><br></p>
<p class="p13">// The Function has to check whether</p>
<p class="p13">// 1.) there are no repetitions</p>
<p class="p13">// 2.) the difference to the last item is of same signum as in the original pitch sequence</p>
<p class="p12"><br></p>
<p class="p13">// keep in mind that, as always, passed collection is of full length in each step,<span class="Apple-converted-space"> </span></p>
<p class="p13">// so we have to restrict to the indices up to i-1</p>
<p class="p11"><br></p>
<p class="p15">(<span class="Apple-converted-space"> </span></p>
<p class="p16">// assuming no pitches repeated</p>
<p class="p15">m = [60, 65, 62, 69, 71];<span class="Apple-converted-space"> </span></p>
<p class="p15">d = m.differentiate.sign;<span class="Apple-converted-space"> </span></p>
<p class="p15">f = { <span class="s6">|x,i,col|</span> col[(0..i-1)].includes(x).not &amp;&amp; ((x - col[i-1]).sign == d[i]) };<span class="Apple-converted-space"> </span></p>
<p class="p15">m.size.enum(m, f);<span class="Apple-converted-space"> </span></p>
<p class="p15">)<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">--&gt; [ [ 60, 65, 62, 69, 71 ], [ 60, 69, 62, 65, 71 ], [ 60, 71, 62, 65, 69 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 65, 69, 60, 62, 71 ], [ 65, 71, 60, 62, 69 ], [ 62, 65, 60, 69, 71 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 62, 69, 60, 65, 71 ], [ 62, 71, 60, 65, 69 ], [ 69, 71, 60, 62, 65 ] ]</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p10"><b>Example 3: <span class="Apple-converted-space">  </span>Partitions of Integers, Scales</b></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p16">// list all partitions of a given integer a into n summands</p>
<p class="p11"><br></p>
<p class="p15">(</p>
<p class="p15">a = 10;</p>
<p class="p15">n = 5;</p>
<p class="p12"><br></p>
<p class="p16">// storage of partial sums</p>
<p class="p16">// ith element will represent sum up to index i-1</p>
<p class="p12"><br></p>
<p class="p15">p = 0!(n+1);</p>
<p class="p12"><br></p>
<p class="p16">// Function should also consider case i = 0</p>
<p class="p12"><br></p>
<p class="p18"><span class="s2">f = { </span>|x,i,col|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s6">var</span> order = (i &gt; 0).if { x &gt;= col[i-1] }{ <span class="s7">true</span> };</p>
<p class="p15"><span class="Apple-tab-span">	</span>p[i+1] = p[i] + x;</p>
<p class="p15"><span class="Apple-tab-span">	</span>order and: {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(i + 1 &lt; n).if {</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// check if partial sums are not too large</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(n - i) * x + p[i] &lt;= a</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}{</p>
<p class="p16"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// partition check at last index i == n-1</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>p[i+1] == a<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p15"><span class="Apple-tab-span">	</span>}</p>
<p class="p15">};</p>
<p class="p12"><br></p>
<p class="p16">// true causes check also at index 0<span class="Apple-tab-span">	</span></p>
<p class="p15">5.enum((1..10), f, <span class="s7">true</span>);<span class="Apple-converted-space"> </span></p>
<p class="p15">)</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, 1, 1, 1, 6 ], [ 1, 1, 1, 2, 5 ], [ 1, 1, 1, 3, 4 ], [ 1, 1, 2, 2, 4 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 1, 1, 2, 3, 3 ], [ 1, 2, 2, 2, 3 ], [ 2, 2, 2, 2, 2 ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p19">// in above Function the given integer and the number of summands are hardcoded.</p>
<p class="p19">// For a general purpose tool better make a function constructor,</p>
<p class="p19">// also build in an arg that determines if solutions should be ascending or not</p>
<p class="p12"><br></p>
<p class="p15">(</p>
<p class="p19">// Function to make boolean value Function depending on sum a and number of summands n</p>
<p class="p20"><span class="s2">g = { </span>|a,n,ascending = true|</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="s8">var</span> p = 0!(n+1);</p>
<p class="p20"><span class="s2"><span class="Apple-tab-span">	</span>{ </span>|x,i,col|<span class="s2"><span class="Apple-converted-space"> </span></span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s8">var</span> order = ((i &gt; 0) &amp;&amp; ascending).if { x &gt;= col[i-1] }{ <span class="s9">true</span> };</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>p[i+1] = p[i] + x;</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>order and: {</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(i + 1 &lt; n).if {</p>
<p class="p19"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// check if partial sums are not too large</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>ascending.if { x }{ 1 } * (n - i) + p[i] &lt;= a</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}{</p>
<p class="p19"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// partition check at last index i == n-1</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>p[i+1] == a<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p15"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p15"><span class="Apple-tab-span">	</span>}</p>
<p class="p15">};</p>
<p class="p12"><br></p>
<p class="p19">// Function for listing all partitions of number a with n summands<span class="Apple-converted-space"> </span></p>
<p class="p12"><br></p>
<p class="p15">h = { <span class="s8">|a,n,pool,ascending = true|</span> n.enum(pool, g.(a,n,ascending), <span class="s9">true</span>) };</p>
<p class="p15">)</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p19">// partitions of number 10 consisting of 5 summands</p>
<p class="p19">// monotone tuples are demanded (so reorder of tuples is neglected)</p>
<p class="p12"><br></p>
<p class="p15">h.(10, 5, (1..10))</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, 1, 1, 1, 6 ], [ 1, 1, 1, 2, 5 ], [ 1, 1, 1, 3, 4 ], [ 1, 1, 2, 2, 4 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 1, 1, 2, 3, 3 ], [ 1, 2, 2, 2, 3 ], [ 2, 2, 2, 2, 2 ] ]</p>
<p class="p12"><br></p>
<p class="p9"><br></p>
<p class="p19">// partitions of number 12, taking order into account (not ascending),</p>
<p class="p19">// lists all possible scales of a certain number of pitches,</p>
<p class="p19">// given as interval arrays</p>
<p class="p21"><br></p>
<p class="p19">// this gives all scales of 7 tones with stepwidth from 1 to 3 semitones.</p>
<p class="p19">// Result contains rotations of interval arrays that are different,</p>
<p class="p19">// e.g. major [2,2,1,2,2,2,1] and dorian [2,1,2,2,2,1,2]</p>
<p class="p12"><br></p>
<p class="p15">x = h.(12, 7, (1..3), <span class="s9">false</span>);</p>
<p class="p15">x.size;</p>
<p class="p9"><br></p>
<p class="p15">-&gt; 266</p>
<p class="p9"><br></p>
<p class="p9"><br></p>
<p class="p10"><b>Example 4: <span class="Apple-converted-space">  </span>Graphs</b></p>
<p class="p11"><br></p>
<p class="p11"><br></p>
<p class="p16">// undirected graph with 9 nodes</p>
<p class="p22"><br></p>
<p class="p23"><span class="s10"><img src="attachments/enum/graph.png" alt="attachments/enum/graph.png"></span></p>
<p class="p12"><br></p>
<p class="p15">(</p>
<p class="p16">// graph represented as array of possible successor nodes</p>
<p class="p15">g = [[1,2], [0,3], [0,3,5], [1,2,4,6], [3,7], [2,6], [3,5,7], [4,6,8], [7]];</p>
<p class="p12"><br></p>
<p class="p16">// Function for finding unused nodes to be connected</p>
<p class="p15">f = { <span class="s6">|x,i,col|</span> col[(0..i-1)].includes(x).not and: { g[col[i-1]].includes(x) } };</p>
<p class="p12"><span class="Apple-tab-span">	</span></p>
<p class="p16">// search for all paths using each node exactly once</p>
<p class="p15">9.enum((0..8), f)</p>
<p class="p15">)</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 1, 0, 2, 5, 6, 3, 4, 7, 8 ], [ 4, 3, 1, 0, 2, 5, 6, 7, 8 ], [ 6, 5, 2, 0, 1, 3, 4, 7, 8 ],<span class="Apple-converted-space"> </span></p>
<p class="p15"><span class="Apple-tab-span">	</span>[ 8, 7, 4, 3, 1, 0, 2, 5, 6 ], [ 8, 7, 4, 3, 6, 5, 2, 0, 1 ], [ 8, 7, 6, 5, 2, 0, 1, 3, 4 ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p16">// give only one random solution - here path of length 8</p>
<p class="p22"><br></p>
<p class="p15">8.enum((0..8), f, order: false, maxNum: 1)</p>
<p class="p12"><br></p>
<p class="p15">-&gt; [ [ 0, 1, 3, 4, 7, 6, 5, 2 ] ]</p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
<p class="p12"><br></p>
</body>
</html>
